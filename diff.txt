diff --git a/.gitignore b/.gitignore
index bf5fbf37..0a74c898 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,7 +3,7 @@ output/
 build/
 class
 *.prof
-*.ini
+
 libclass.a
 *out
 python/classy.c
diff --git a/include/background.h b/include/background.h
index 84953f6f..f51b238c 100755
--- a/include/background.h
+++ b/include/background.h
@@ -61,6 +61,45 @@ struct background
 
   double Omega0_fld; /**< \f$ \Omega_{0 de} \f$: fluid */
 
+
+  double Omega_EDE2;  //New EDE  before decay
+
+  double Omega_trigger_decay;
+
+  double Omega0_EDE2; //New EDE today
+
+  double w0_EDE; //New EDE eos parameter
+
+  short Junction_tag;
+
+  short DMa_tag;
+
+  double WKB_trigger_H_over_m;
+
+  double Bubble_trigger_H_over_m;
+
+  short WKB_flag;
+
+  double rho_scf_WKB;
+
+  double a_WKB;
+  
+  double EDE2_clock_mass;
+
+  double EDE2_clock_ini;
+
+  double EDE2_clock_pert_ini;
+
+  double three_eos_EDE;
+
+  short decay_flag; 
+  double tau_decay;
+  double a_decay;
+ 
+
+  double z_decay; /* New EDE decay redshift */
+
+
   enum equation_of_state fluid_equation_of_state; /**< parametrisation scheme for fluid equation of state */
 
   double w0_fld; /**< \f$ w0_{DE} \f$: current fluid equation of state parameter */
@@ -188,6 +227,7 @@ struct background
   int index_bg_rho_lambda;    /**< cosmological constant density */
   int index_bg_rho_fld;       /**< fluid density */
   int index_bg_w_fld;         /**< fluid equation of state */

   int index_bg_rho_ur;        /**< relativistic neutrinos/relics density */
   int index_bg_rho_idm_dr;    /**< density of dark matter interacting with dark radiation */
   int index_bg_rho_idr;       /**< density of interacting dark radiation */
@@ -306,6 +346,9 @@ struct background
   short has_idm_dr;    /**< presence of dark matter interacting with dark radiation? */
   short has_curvature; /**< presence of global spatial curvature? */
 
+  short has_EDE_decay; /**< presence of decay? */
+  short has_EDE_pert;  /**< presence of perturbations*/
+
   //@}
 
   /**
diff --git a/include/input.h b/include/input.h
index b4586fab..c6690222 100755
--- a/include/input.h
+++ b/include/input.h
@@ -299,8 +299,15 @@ extern "C" {
                           int input_verbose,
                           ErrorMsg errmsg
                           );
+  /* New EDE */
+  int find_z_decay(
+		   struct precision * ppr,
+		   struct background *pba,
+		   ErrorMsg errmsg
+		   );
 
 
+  
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/perturbations.h b/include/perturbations.h
index 49c8f4dc..4f4d8cbf 100644
--- a/include/perturbations.h
+++ b/include/perturbations.h
@@ -32,7 +32,8 @@ enum tca_idm_dr_flags {tca_idm_dr_on, tca_idm_dr_off};
 enum rsa_idr_flags {rsa_idr_off, rsa_idr_on};
 enum ufa_flags {ufa_off, ufa_on};
 enum ncdmfa_flags {ncdmfa_off, ncdmfa_on};
-
+enum CCa_flags {CCa_on, CCa_off}; /* New EDE, before decay CCa_on, corresponding to no perts. */
+enum sda_flags {sda_off, sda_on};
 //@}
 
 /**
@@ -172,6 +173,9 @@ struct perturbs
   double three_ceff2_ur;/**< 3 x effective squared sound speed for the ultrarelativistic perturbations */
   double three_cvis2_ur;/**< 3 x effective viscosity parameter for the ultrarelativistic perturbations */
 
+  double three_ceff2_EDE;
+  double three_cvis2_EDE;
+  
   double z_max_pk; /**< when we compute only the matter spectrum / transfer functions, but not the CMB, we are sometimes interested to sample source functions at very high redshift, way before recombination. This z_max_pk will then fix the initial sampling time of the sources. */
 
   double * alpha_idm_dr; /**< Angular contribution to collisional term at l>=2 for idm_fr-idr */
@@ -242,6 +246,7 @@ struct perturbs
   short has_source_delta_scf;   /**< do we need source for delta from scalar field? */
   short has_source_delta_dr;    /**< do we need source for delta of decay radiation? */
   short has_source_delta_ur;    /**< do we need source for delta of ultra-relativistic neutrinos/relics? */

   short has_source_delta_idr;   /**< do we need source for delta of interacting dark radiation? */
   short has_source_delta_idm_dr;/**< do we need source for delta of interacting dark matter (with dr)? */
   short has_source_delta_ncdm;  /**< do we need source for delta of all non-cold dark matter species (e.g. massive neutrinos)? */
@@ -256,6 +261,7 @@ struct perturbs
   short has_source_theta_scf;   /**< do we need source for theta of scalar field? */
   short has_source_theta_dr;    /**< do we need source for theta of ultra-relativistic neutrinos/relics? */
   short has_source_theta_ur;    /**< do we need source for theta of ultra-relativistic neutrinos/relics? */
+  short has_source_theta_EDE;
   short has_source_theta_idr;   /**< do we need source for theta of interacting dark radiation? */
   short has_source_theta_idm_dr;/**< do we need source for theta of interacting dark matter (with dr)? */
   short has_source_theta_ncdm;  /**< do we need source for theta of all non-cold dark matter species (e.g. massive neutrinos)? */
@@ -289,6 +295,7 @@ struct perturbs
   int index_tp_delta_scf;  /**< index value for delta of scalar field */
   int index_tp_delta_dr; /**< index value for delta of decay radiation */
   int index_tp_delta_ur; /**< index value for delta of ultra-relativistic neutrinos/relics */

   int index_tp_delta_idr; /**< index value for delta of interacting dark radiation */
   int index_tp_delta_idm_dr;/**< index value for delta of interacting dark matter (with dr)*/
   int index_tp_delta_ncdm1; /**< index value for delta of first non-cold dark matter species (e.g. massive neutrinos) */
@@ -305,6 +312,7 @@ struct perturbs
   int index_tp_theta_fld;   /**< index value for theta of dark energy */
   int index_tp_theta_scf;   /**< index value for theta of scalar field */
   int index_tp_theta_ur;    /**< index value for theta of ultra-relativistic neutrinos/relics */
+  int index_tp_theta_EDE;    /*New EDE*/
   int index_tp_theta_idr;   /**< index value for theta of interacting dark radiation */
   int index_tp_theta_idm_dr;/**< index value for theta of interacting dark matter (with dr)*/
   int index_tp_theta_dr;    /**< index value for F1 of decay radiation */
@@ -475,6 +483,16 @@ struct perturb_vector
   int index_pt_shear_ur; /**< shear of ultra-relativistic neutrinos/relics */
   int index_pt_l3_ur;    /**< l=3 of ultra-relativistic neutrinos/relics */
   int l_max_ur;          /**< max momentum in Boltzmann hierarchy (at least 3) */
+
+  int index_pt_delta_EDE;
+  int index_pt_theta_EDE;
+  int index_pt_shear_EDE;
+  int index_pt_delta_clock;
+  int index_pt_rho_plus_p_theta_clock;
+  int index_pt_l3_EDE;
+  int l_max_EDE;
+
+  
   int index_pt_delta_idr; /**< density of interacting dark radiation */
   int index_pt_theta_idr; /**< velocity of interacting dark radiation */
   int index_pt_shear_idr; /**< shear of interacting dark radiation */
@@ -619,6 +637,8 @@ struct perturb_workspace
   int index_ap_tca_idm_dr; /**< index for dark tight-coupling approximation (idm-idr) */
   int index_ap_rsa_idr; /**< index for dark radiation streaming approximation */
   int index_ap_ufa; /**< index for ur fluid approximation */
   int index_ap_ncdmfa; /**< index for ncdm fluid approximation */
   int ap_size;      /**< number of relevant approximations for a given mode */
 
diff --git a/include/precisions.h b/include/precisions.h
index 3fc78cd1..923333fc 100644
--- a/include/precisions.h
+++ b/include/precisions.h
@@ -18,6 +18,10 @@ class_precision_parameter(back_integration_stepsize,double,7.e-3)
 /**
  * Tolerance of the background integration, giving the allowed relative integration error.
  */

 class_precision_parameter(tol_background_integration,double,1.e-2)
 /**
  * Tolerance of the deviation of \f$ \Omega_r \f$ from 1 for which to start integration:
@@ -277,6 +281,10 @@ class_precision_parameter(idr_streaming_trigger_tau_c_over_tau,double,10.0) /**<
 
 class_precision_parameter(ur_fluid_approximation,int,ufa_CLASS) /**< method for ultra relativistic fluid approximation */
 
diff --git a/python/cclassy.pxd b/python/cclassy.pxd
index 9a48f944..e23bd0f6 100644
--- a/python/cclassy.pxd
+++ b/python/cclassy.pxd
@@ -63,6 +63,7 @@ cdef extern from "class.h":
         double T_cmb
         double h
         double H0
+        double z_decay
         double age
         double conformal_age
         double * m_ncdm_in_eV
diff --git a/python/classy.pyx b/python/classy.pyx
index 9450c9ec..83620041 100644
--- a/python/classy.pyx
+++ b/python/classy.pyx
@@ -1670,6 +1670,8 @@ cdef class Class:
                 value = self.ba.h*100
             elif name == 'Omega0_lambda' or name == 'Omega_Lambda':
                 value = self.ba.Omega0_lambda
+            elif name == 'z_decay':
+                value = self.ba.z_decay
             elif name == 'Omega0_fld':
                 value = self.ba.Omega0_fld
             elif name == 'age':
diff --git a/python/setup.py b/python/setup.py
index c2920577..bd3c6203 100644
--- a/python/setup.py
+++ b/python/setup.py
@@ -7,6 +7,8 @@ import os
 import subprocess as sbp
 import os.path as osp
 

+
 # Recover the gcc compiler
 GCCPATH_STRING = sbp.Popen(
     ['gcc', '-print-libgcc-file-name'],
diff --git a/source/background.c b/source/background.c
index b13c0646..9b35e1a2 100755
--- a/source/background.c
+++ b/source/background.c
@@ -270,6 +270,7 @@ int background_functions(
   int n_ncdm;
   /* fluid's time-dependent equation of state parameter */
   double w_fld, dw_over_da, integral_fld;
+  double rho_decay;
   /* scale factor */
   double a;
   /* scalar field quantities */
@@ -348,8 +349,18 @@ int background_functions(
     pvecback[pba->index_bg_V_scf] = V_scf(pba,phi); //V_scf(pba,phi); //write here potential as function of phi
     pvecback[pba->index_bg_dV_scf] = dV_scf(pba,phi); // dV_scf(pba,phi); //potential' as function of phi
     pvecback[pba->index_bg_ddV_scf] = ddV_scf(pba,phi); // ddV_scf(pba,phi); //potential'' as function of phi
+
+    /*Flo*/ /*Here we check if we are in the WKB regime*/
+    //if( pba->EDE2_clock_mass * pba->WKB_trigger_H_over_m <  pvecback[pba->index_bg_H]){
     pvecback[pba->index_bg_rho_scf] = (phi_prime*phi_prime/(2*a*a) + V_scf(pba,phi))/3.; // energy of the scalar field. The field units are set automatically by setting the initial conditions
     pvecback[pba->index_bg_p_scf] =(phi_prime*phi_prime/(2*a*a) - V_scf(pba,phi))/3.; // pressure of the scalar field
+    //}
+    //else{ /*WKB approximation: rho= rho_WKB (a/a_WKB)^3*/
+    //pvecback[pba->index_bg_rho_scf] = 0.; //pba->rho_scf_WKB * pow(a_rel / pba->a_WKB,-3.);
+    //pvecback[pba->index_bg_p_scf] = 0.;
+    //}
+
+    
     rho_tot += pvecback[pba->index_bg_rho_scf];
     p_tot += pvecback[pba->index_bg_p_scf];
     dp_dloga += 0.0; /** <-- This depends on a_prime_over_a, so we cannot add it now! */
@@ -434,6 +445,30 @@ int background_functions(
     rho_r += pvecback[pba->index_bg_rho_ur];
   }
 
+  /* New EDE*/
+       
+  if (pba->has_EDE_decay == _TRUE_) {
+
+    if (a_rel < pba->a_decay || pba->a_decay ==0 ) {  
+      /*w = -1 phase*/
+      rho_decay = pba->Omega_EDE2 * pow(pba->H0,2); /*Note the class convention according to which 3 Mpl^2 is absorbed in rho, i.e. rho_crit = H0^2. */
+      pvecback[pba->index_bg_rho_EDE2] = rho_decay; /* Save value of rho in array for later use.*/
+      p_tot -= rho_decay; /*add pressure contribution*/
+      rho_tot += rho_decay; /*add energy contribution*/
+    }
+    else {
+
+      /* decay phase with w > 1/3 */
+      rho_decay = (pba->Omega_EDE2 ) * pow(pba->H0,2) * pow(pba->a_decay / a_rel, 3.+pba->three_eos_EDE);
+      pvecback[pba->index_bg_rho_EDE2] = rho_decay;
+      p_tot += (pba->three_eos_EDE / 3.)*rho_decay;
+      rho_tot += rho_decay;
+      dp_dloga += (-(3.+pba->three_eos_EDE)*pba->three_eos_EDE/3.)*pvecback[pba->index_bg_rho_EDE2];
+    }
+  }
+
+  
+
   /* interacting dark matter */
   if (pba->has_idm_dr == _TRUE_) {
     pvecback[pba->index_bg_rho_idm_dr] = pba->Omega0_idm_dr * pow(pba->H0,2) / pow(a_rel,3);
@@ -886,6 +921,8 @@ int background_indices(
   pba->has_idr = _FALSE_;
   pba->has_idm_dr = _FALSE_;
   pba->has_curvature = _FALSE_;
+  pba->has_EDE_decay = _FALSE_;
+  pba->has_EDE_pert = _FALSE_; 
 
   if (pba->Omega0_cdm != 0.)
     pba->has_cdm = _TRUE_;
@@ -920,6 +957,15 @@ int background_indices(
   if (pba->sgnK != 0)
     pba->has_curvature = _TRUE_;
 
+
+  /*New EDE*/
+  if (pba->Omega_EDE2 != 0) {
+    pba->has_EDE_decay = _TRUE_;
+    pba->has_EDE_pert = _TRUE_; /*If this flag is set, perturbations are included. This is the only consistent choice.*/
+    if (pba->EDE2_clock_ini != 0.) /*Here we decide if we include a clock field*/
+      pba->has_scf = _TRUE_;
+  }
+
   /** - initialize all indices */
 
   index_bg=0;
@@ -973,6 +1019,9 @@ int background_indices(
   class_define_index(pba->index_bg_rho_fld,pba->has_fld,index_bg,1);
   class_define_index(pba->index_bg_w_fld,pba->has_fld,index_bg,1);
 
+  /* index for New EDE fluid*/
+ 
+
   /* - index for ultra-relativistic neutrinos/species */
   class_define_index(pba->index_bg_rho_ur,pba->has_ur,index_bg,1);
 
@@ -1055,10 +1104,8 @@ int background_indices(
   /* -> energy density in fluid */
   class_define_index(pba->index_bi_rho_fld,pba->has_fld,index_bi,1);
 
-  /* -> scalar field and its derivative wrt conformal time (Zuma) */
-  class_define_index(pba->index_bi_phi_scf,pba->has_scf,index_bi,1);
-  class_define_index(pba->index_bi_phi_prime_scf,pba->has_scf,index_bi,1);
 
+  
   /* End of {B} variables, now continue with {C} variables */
   pba->bi_B_size = index_bi;
 
@@ -1072,9 +1119,19 @@ int background_indices(
   class_define_index(pba->index_bi_D,_TRUE_,index_bi,1);
   class_define_index(pba->index_bi_D_prime,_TRUE_,index_bi,1);
 
+
+  
+  /* -> scalar field and its derivative wrt conformal time (Zuma) */
+  class_define_index(pba->index_bi_phi_scf,pba->has_scf,index_bi,1);
+  class_define_index(pba->index_bi_phi_prime_scf,pba->has_scf,index_bi,1);
+
+
   /* -> index for conformal time in vector of variables to integrate */
   class_define_index(pba->index_bi_tau,_TRUE_,index_bi,1);
 
+
+  
+
   /* -> end of indices in the vector of variables to integrate */
   pba->bi_size = index_bi;
 
@@ -1669,6 +1726,9 @@ int background_solve(
   /* comoving radius coordinate in Mpc (equal to conformal distance in flat case) */
   double comoving_radius=0.;
 
+  double a;
+  double d, delta_z;
+
   bpaw.pba = pba;
   class_alloc(pvecback,pba->bg_size*sizeof(double),pba->error_message);
   bpaw.pvecback = pvecback;
@@ -1704,6 +1764,9 @@ int background_solve(
 
   /** - loop over integration steps: call background_functions(), find step size, save data in growTable with gt_add(), perform one step with generic_integrator(), store new value of tau */
 
+  /*New EDE*/ /*reset deycay_flag before integration starts*/
+  pba->decay_flag = _FALSE_;
+  
   while (pvecback_integration[pba->index_bi_a] < pba->a_today) {
 
     tau_start = tau_end;
@@ -1722,6 +1785,38 @@ int background_solve(
       /* no possible segmentation fault here: non-zeroness of "a" has been checked in background_functions() */
     }
 
+
+       /*New EDE*/
+
+    if (pba->has_EDE_decay == _TRUE_){
+       a=pvecback_integration[pba->index_bi_a];
+
+       if ((pba->EDE2_clock_mass * pba->Bubble_trigger_H_over_m > pvecback[pba->index_bg_H]) *1.01   &&(pba->decay_flag == _TRUE_)) {
+	 pvecback_integration[pba->index_bi_phi_scf] = 0.;
+	 pvecback_integration[pba->index_bi_phi_prime_scf] = 0.;
+	 gi.n=pba->bi_size-3;
+       }
+       
+       /* Check if EDE has decayed. */
+       if ((pba->EDE2_clock_mass * pba->Bubble_trigger_H_over_m > pvecback[pba->index_bg_H])&&(pba->decay_flag == _FALSE_)) {
+	 pba->decay_flag = _TRUE_; 
+	 pba->z_decay = 1. /a -1.;
+	 pba->a_decay = a;
+	 pba->Omega_trigger_decay = pvecback[pba->index_bg_rho_scf] /  pow(pba->H0,2);  
+	 if (pba->background_verbose > 0){ 
+	   printf("New EDE decayed at redshift: %f ; fraction New EDE: %f; fraction clock: %e \n",pba->z_decay,  pba->Omega_EDE2 * pow(pba->H0,2) / (pow(pvecback[pba->index_bg_H],2)), pvecback[pba->index_bg_rho_scf] / pow(pvecback[pba->index_bg_H],2) );
+	 }
+	 }
+       /*Flo:  make integration finer around decay time*/
+       /*delta_z=2*ppr->back_integration_stepsize/a;
+       if ((1./a-1. <   pba->z_decay + delta_z) && (1./a-1. > pba->z_decay - delta_z) && (pba->z_decay >1.)  ){
+	 //printf("decay: %f, a: %e, z_decay: %e, counter: %d \n", 1./a - 1.,a,pba->z_decay,d);
+	 d= abs(1./a-1.-pba->z_decay)/delta_z;
+	 tau_end = tau_start + ppr->back_integration_stepsize/(1+ppr->decay_res_enhancement*exp(-d*6)) / (pvecback_integration[pba->index_bi_a]*pvecback[pba->index_bg_H]);
+	 }*/
+       
+    }
+
     class_test((tau_end-tau_start)/tau_start < ppr->smallest_allowed_variation,
                pba->error_message,
                "integration step: relative change in time =%e < machine precision : leads either to numerical error or infinite loop",(tau_end-tau_start)/tau_start);
@@ -1746,7 +1841,9 @@ int background_solve(
 
     /* -> store value of tau */
     pvecback_integration[pba->index_bi_tau]=tau_end;
-
+    //printf("v1 %f, v2: %f",pba->index_bi_tau,pba->index_bi_phi_scf);
+    //yif (pba->has_scf)
+    //pvecback_integration[pba->index_bi_phi_prime_scf] = 0.;
   }
 
   /** - save last data in growTable with gt_add() */
@@ -1895,6 +1992,18 @@ int background_solve(
                -pba->background_table[pba->index_bg_rho_g])
     /(7./8.*pow(4./11.,4./3.)*pba->background_table[pba->index_bg_rho_g]);
 
+
+  /*New EDE*/ /*Calculate abundance of scf and EDE today*/
+  if (pba->has_scf == _TRUE_ && pba->has_EDE_decay ==_TRUE_){
+    pba->Omega0_scf = pvecback[pba->index_bg_rho_scf]/pvecback[pba->index_bg_rho_crit];
+  }
+  
+  if (pba->has_EDE_decay ==_TRUE_){
+    pba->Omega0_EDE2 = pvecback[pba->index_bg_rho_EDE2]/pvecback[pba->index_bg_rho_crit];
+  }
+
+  
+
   /** - done */
   if (pba->background_verbose > 0) {
     printf(" -> age = %f Gyr\n",pba->age);
@@ -1911,7 +2020,17 @@ int background_solve(
              pba->Omega0_dr+pba->Omega0_dcdm,pba->Omega0_dcdmdr);
       printf("     -> Omega_ini_dcdm/Omega_b = %f\n",pba->Omega_ini_dcdm/pba->Omega0_b);
     }
-    if (pba->has_scf == _TRUE_){
+    if (pba->has_scf == _TRUE_ && pba->has_EDE_decay ==_TRUE_){
+
+      printf("  -> EDE details:\n");
+      printf("     -> Bubble_trigger: %f \n", pba->Bubble_trigger_H_over_m);
+      printf("     -> H/H0-1: %e \n",pvecback[pba->index_bg_H]/pba->H0-1);
+      printf("     -> resolution_enhancement: %e \n",ppr->decay_res_enhancement);
+      printf("     -> Omega_scf = %g, scf_ini = %g, scf_pert_ini = %g \n",
+             pvecback[pba->index_bg_rho_scf]/pvecback[pba->index_bg_rho_crit],pba->EDE2_clock_ini, pba->EDE2_clock_pert_ini);   
+    }
+    
+    if (pba->has_scf == _TRUE_ && pba->has_EDE_decay == _FALSE_){
       printf("    Scalar field details:\n");
       printf("     -> Omega_scf = %g, wished %g\n",
              pvecback[pba->index_bg_rho_scf]/pvecback[pba->index_bg_rho_crit], pba->Omega0_scf);
@@ -2081,7 +2200,17 @@ int background_initial_conditions(
    * - Check equations and signs. Sign of phi_prime?
    * - is rho_ur all there is early on?
    */
-  if(pba->has_scf == _TRUE_){
+
+   /*New EDE*/ /*Here we specify the initial conditions for the scalar field in slow roll approximation. We set it on the attractor.*/
+  /* phi'_ini = -1/5 * phi_ini a^2 m^2  / (a H) where H = sqrt(rho) ins class conventions. */
+  
+  if(pba->has_EDE_decay == _TRUE_ && pba->has_scf == _TRUE_){
+    
+    pvecback_integration[pba->index_bi_phi_scf] = pba->phi_ini_scf;
+    pvecback_integration[pba->index_bi_phi_prime_scf] = -1./5. * pba->phi_ini_scf *pow(pba->EDE2_clock_mass ,2) / pow(rho_rad,0.5) * a;
+    // printf("initial value: %e; \n",pvecback_integration[pba->index_bi_phi_prime_scf]);
+  }
+  else if(pba->has_scf == _TRUE_){
     scf_lambda = pba->scf_parameters[0];
     if(pba->attractor_ic_scf == _TRUE_){
       pvecback_integration[pba->index_bi_phi_scf] = -1/scf_lambda*
@@ -2260,6 +2389,8 @@ int background_output_titles(struct background * pba,
   class_store_columntitle(titles,"(.)rho_lambda",pba->has_lambda);
   class_store_columntitle(titles,"(.)rho_fld",pba->has_fld);
   class_store_columntitle(titles,"(.)w_fld",pba->has_fld);
+
+  class_store_columntitle(titles,"(.)rho_EDE2",pba->has_EDE_decay);
   class_store_columntitle(titles,"(.)rho_ur",pba->has_ur);
   class_store_columntitle(titles,"(.)rho_idr",pba->has_idr);
   class_store_columntitle(titles,"(.)rho_idm_dr",pba->has_idm_dr);
@@ -2319,6 +2450,7 @@ int background_output_data(
     class_store_double(dataptr,pvecback[pba->index_bg_rho_lambda],pba->has_lambda,storeidx);
     class_store_double(dataptr,pvecback[pba->index_bg_rho_fld],pba->has_fld,storeidx);
     class_store_double(dataptr,pvecback[pba->index_bg_w_fld],pba->has_fld,storeidx);
+    class_store_double(dataptr,pvecback[pba->index_bg_rho_EDE2],pba->has_EDE_decay,storeidx);
     class_store_double(dataptr,pvecback[pba->index_bg_rho_ur],pba->has_ur,storeidx);
     class_store_double(dataptr,pvecback[pba->index_bg_rho_idr],pba->has_idr,storeidx);
     class_store_double(dataptr,pvecback[pba->index_bg_rho_idm_dr],pba->has_idm_dr,storeidx);
@@ -2444,10 +2576,23 @@ int background_derivs(
 
   if (pba->has_scf == _TRUE_){
     /** - Scalar field equation: \f$ \phi'' + 2 a H \phi' + a^2 dV = 0 \f$  (note H is wrt cosmic time) */
+    /*Flo*/ /* WKB approximation to avoid problems with  oscillations at very late times*/
+
+    /*We turn scf off once H/mass < Bubble_trigger_h_over_m with little safety margin*/
+    //if ( pba->EDE2_clock_mass * pba->Bubble_trigger_H_over_m <  pvecback[pba->index_bg_H]*(1.01)) {
+      /*normal evolution*/
     dy[pba->index_bi_phi_scf] = y[pba->index_bi_phi_prime_scf];
-    dy[pba->index_bi_phi_prime_scf] = - y[pba->index_bi_a]*
+
+    dy[pba->index_bi_phi_prime_scf] = - y[pba->index_bi_a] *
       (2*pvecback[pba->index_bg_H]*y[pba->index_bi_phi_prime_scf]
        + y[pba->index_bi_a]*dV_scf(pba,y[pba->index_bi_phi_scf])) ;
+      //} 
+      //else{
+      //dy[pba->index_bi_phi_scf] = 0 ;
+      //dy[pba->index_bi_phi_prime_scf] = 0;
+      //y[pba->index_bi_phi_scf] =0.;
+      //y[pba->index_bi_phi_prime_scf] =0.;
+      //}
   }
 
   return _SUCCESS_;
@@ -2561,22 +2706,39 @@ double ddV_p_scf(
 /** Fianlly we can obtain the overall potential \f$ V = V_p*V_e \f$
  */
 
+/*Flo*/ /*Here we implement out clock potential and its derivatives*/
+
 double V_scf(
              struct background *pba,
              double phi) {
-  return  V_e_scf(pba,phi)*V_p_scf(pba,phi);
+  if (pba->has_EDE_decay == _TRUE_){
+    return  1./2. * pba->EDE2_clock_mass * pba->EDE2_clock_mass * phi*phi;
+  }
+  else{
+     return  V_e_scf(pba,phi)*V_p_scf(pba,phi);
+  }
 }
 
 double dV_scf(
               struct background *pba,
-              double phi) {
-  return dV_e_scf(pba,phi)*V_p_scf(pba,phi) + V_e_scf(pba,phi)*dV_p_scf(pba,phi);
+	      double phi) {
+  if (pba->has_EDE_decay == _TRUE_){
+    return pba->EDE2_clock_mass * pba->EDE2_clock_mass * phi;
+  }
+  else{
+    return dV_e_scf(pba,phi)*V_p_scf(pba,phi) + V_e_scf(pba,phi)*dV_p_scf(pba,phi);
+  }
 }
 
 double ddV_scf(
                struct background *pba,
                double phi) {
-  return ddV_e_scf(pba,phi)*V_p_scf(pba,phi) + 2*dV_e_scf(pba,phi)*dV_p_scf(pba,phi) + V_e_scf(pba,phi)*ddV_p_scf(pba,phi);
+  if (pba->has_EDE_decay == _TRUE_){
+    return pba->EDE2_clock_mass * pba->EDE2_clock_mass;
+  }
+  else{
+    return ddV_e_scf(pba,phi)*V_p_scf(pba,phi) + 2*dV_e_scf(pba,phi)*dV_p_scf(pba,phi) + V_e_scf(pba,phi)*ddV_p_scf(pba,phi);
+  }
 }
 
 /**
@@ -2650,7 +2812,7 @@ int background_output_budget(
       }
     }
 
-    if(pba->has_lambda || pba->has_fld || pba->has_scf || pba->has_curvature){
+    if(pba->has_lambda || pba->has_fld || pba->has_scf || pba->has_curvature || pba->has_EDE_decay){
       printf(" ---> Other Content \n");
     }
     if(pba->has_lambda){
@@ -2661,6 +2823,10 @@ int background_output_budget(
       _class_print_species_("Dark Energy Fluid",fld);
       budget_other+=pba->Omega0_fld;
     }
+    if(pba->has_EDE_decay){
+      _class_print_species_("New EDE",EDE2);
+      budget_other+=pba->Omega0_EDE2;
+    }
     if(pba->has_scf){
       _class_print_species_("Scalar Field",scf);
       budget_other+=pba->Omega0_scf;
diff --git a/source/input.c b/source/input.c
index a4b32679..089598ea 100644
--- a/source/input.c
+++ b/source/input.c
@@ -1246,6 +1246,53 @@ int input_read_parameters(
   if (pba->K > 0.) pba->sgnK = 1;
   else if (pba->K < 0.) pba->sgnK = -1;
 
+
+  /* EDE */
+  class_read_double("Omega_EDE2",pba->Omega_EDE2);
+  class_read_double("three_eos_EDE",pba->three_eos_EDE);
+  class_read_double("three_ceff2_EDE",ppt->three_ceff2_EDE);
+  class_read_double("three_cvis2_EDE",ppt->three_cvis2_EDE);
+  class_read_double("EDE2_clock_ini",pba->EDE2_clock_ini);
+  class_read_double("EDE2_clock_pert_ini",pba->EDE2_clock_pert_ini);
+  class_read_double("WKB_trigger_H_over_m",pba->WKB_trigger_H_over_m);
+  class_read_double("Bubble_trigger_H_over_m",pba->Bubble_trigger_H_over_m);
+  class_read_double("EDE2_clock_mass",pba->EDE2_clock_mass);
+  class_read_double("Junction_tag", pba->Junction_tag)
+  class_read_double("DMa_tag", pba->DMa_tag)
+    
+    if (pba->Omega_EDE2 > 0) {
+      if (pba->EDE2_clock_ini !=0){
+	pba->phi_ini_scf = pba->EDE2_clock_ini;
+	pba->phi_prime_ini_scf = 0; //This value is set to the attractor later.
+      }
+      /*Here we do a first run of the background module to get a good guess for z_decay. For this we do not need a super precise value of Omega_lambda as the decay happens during rad domination. */
+      class_read_double("background_verbose",pba->background_verbose);
+      class_read_double("back_integration_stepsize",ppr->back_integration_stepsize);
+
+
+      pba->Omega0_lambda= 1. - pba->Omega0_k - Omega_tot;
+      
+      if (pba->background_verbose >1){
+	printf("trigger mass: %f, Omega_EDE: %e, EOS: %f \n",pba->EDE2_clock_mass,pba->Omega_EDE2,pba->three_eos_EDE);
+     	printf("First run to estimate Omega0_EDE with Omega0_lambda: %e \n",pba->Omega0_lambda);
+      }
+      
+      
+      
+      class_call(find_z_decay(ppr,pba,errmsg),errmsg,errmsg);
+
+      pba->Omega0_lambda= 1. - pba->Omega0_k - Omega_tot - pba->Omega0_EDE2 - pba->Omega0_scf;
+      if (pba->background_verbose >1)
+	printf("Second run to estimate Omega0_EDE with Omega0_lambda: %e \n",pba->Omega0_lambda);
+      
+      
+      class_call(find_z_decay(ppr,pba,errmsg),errmsg,errmsg);
+      
+      
+      Omega_tot += pba->Omega0_EDE2;
+      Omega_tot += pba->Omega0_scf;
+  }
+
   /** - Omega_0_lambda (cosmological constant), Omega0_fld (dark energy fluid), Omega0_scf (scalar field) */
 
   class_call(parser_read_double(pfc,"Omega_Lambda",&param1,&flag1,errmsg),
@@ -1370,7 +1417,7 @@ int input_read_parameters(
   }
 
   /* Additional SCF parameters: */
-  if (pba->Omega0_scf != 0.){
+  if (pba->Omega0_scf != 0. && pba->EDE2_clock_ini == 0){
     /** - Read parameters describing scalar field potential */
     class_call(parser_read_list_of_doubles(pfc,
                                            "scf_parameters",
@@ -3214,10 +3261,28 @@ int input_default_params(
   pba->w0_fld = -1.;
   pba->wa_fld = 0.;
   pba->Omega_EDE = 0.;
+  pba->Omega_trigger_decay = 0.;
+  pba->three_eos_EDE = 1.;
   pba->cs2_fld = 1.;
 
   pba->shooting_failed = _FALSE_;
 
+
+  /* - New EDE parameters */
+
+  pba->Omega_EDE2 = 0.; 
+  pba->Omega0_EDE2 = 0.;
+  pba->decay_flag = _FALSE_;
+  pba->Junction_tag = 1;
+  pba->DMa_tag = 1;
+  pba->EDE2_clock_ini = 0;
+  pba->EDE2_clock_pert_ini = 0;
+  
+  pba->Bubble_trigger_H_over_m = 1.;
+  pba->EDE2_clock_mass = 0.;
+  pba->z_decay = 0.; 
+
+
   /** - thermodynamics structure */
 
   pth->YHe=_BBN_;
@@ -3317,6 +3382,11 @@ int input_default_params(
   ppt->three_ceff2_ur=1.;
   ppt->three_cvis2_ur=1.;
 
+  /* New EDE fluctuation parameters*/
+  ppt->three_ceff2_EDE=1.;
+  ppt->three_cvis2_EDE=1.;
+
+
   ppt->z_max_pk=0.;
 
   ppt->selection_num=1;
@@ -4180,6 +4250,27 @@ int compare_doubles(const void *a,const void *b) {
   return 0;
 }
 
+/*New EDE / This function integrates the bg to get a first estimate for z_decay, Omega0_EDE, Omega0_scf*/
+int find_z_decay(
+		 struct precision * ppr,
+		 struct background *pba,
+		 ErrorMsg errmsg
+		 ){
+  double verbose_safe;
+  double back_integration_stepsize_safe;
+  //printf("Find z_decay... \n");
+    
+  verbose_safe=pba->background_verbose;
+  //back_integration_stepsize_safe=ppr->back_integration_stepsize;
+  pba->background_verbose=0;
+  //ppr->back_integration_stepsize=0.01;
+  //printf("a ini: %e \n", ppr->a_ini_over_a_today_default);
+  class_call(background_init(ppr,pba), pba->error_message, errmsg);
+  class_call(background_free_noinput(pba), pba->error_message, errmsg);
+  pba->background_verbose=verbose_safe;
+  //ppr->back_integration_stepsize=back_integration_stepsize_safe;
+  return _SUCCESS_;
+}
 
 /**
  * Perform preliminary steps fur using the method called Pk_equal,
diff --git a/source/perturbations.c b/source/perturbations.c
index 6afc1977..aca88476 100644
--- a/source/perturbations.c
+++ b/source/perturbations.c
@@ -510,6 +510,14 @@ int perturb_init(
       printf("Computing sources\n");
   }
 
+  if (pba->has_EDE_pert && ppt->perturbations_verbose > 1){
+    printf("  -> EDE perturbation details:\n");
+    printf("     -> 3ceff2: %f, 3cvis2: %f \n",ppt->three_ceff2_EDE,ppt->three_cvis2_EDE);
+    printf("     -> Junction_tag: %d \n",pba->Junction_tag);
+    printf("     -> EDE sub dom condition: %f \n",ppr->sub_dom_cond);
+    
+  }
+
   class_test((ppt->gauge == synchronous) && (pba->has_cdm == _FALSE_),
              ppt->error_message,
              "In the synchronous gauge, it is not self-consistent to assume no CDM: the later is used to define the initial timelike hypersurface. You can either add a negligible amount of CDM or switch to newtonian gauge");
@@ -1046,6 +1054,8 @@ int perturb_indices_of_perturbs(
   ppt->has_source_delta_scf = _FALSE_;
   ppt->has_source_delta_dr = _FALSE_;
   ppt->has_source_delta_ur = _FALSE_;
+  ppt->has_source_delta_EDE = _FALSE_; 
+  ppt->has_source_theta_EDE = _FALSE_; 
   ppt->has_source_delta_idr = _FALSE_;
   ppt->has_source_delta_idm_dr = _FALSE_;
   ppt->has_source_delta_ncdm = _FALSE_;
@@ -1147,10 +1157,15 @@ int perturb_indices_of_perturbs(
           ppt->has_source_delta_dcdm = _TRUE_;
         if (pba->has_fld == _TRUE_)
           ppt->has_source_delta_fld = _TRUE_;
-        if (pba->has_scf == _TRUE_)
-          ppt->has_source_delta_scf = _TRUE_;
+	/*Ignore contribution of trigger field to density_transfer*/
+	if (pba->has_scf == _TRUE_)
+	  ppt->has_source_delta_scf = _TRUE_;
         if (pba->has_ur == _TRUE_)
           ppt->has_source_delta_ur = _TRUE_;
+
+	if (pba->has_EDE_pert == _TRUE_)
+          ppt->has_source_delta_EDE = _TRUE_;
+
         if (pba->has_idr == _TRUE_)
           ppt->has_source_delta_idr = _TRUE_;
         if (pba->has_idm_dr == _TRUE_)
@@ -1178,10 +1193,15 @@ int perturb_indices_of_perturbs(
           ppt->has_source_theta_dcdm = _TRUE_;
         if (pba->has_fld == _TRUE_)
           ppt->has_source_theta_fld = _TRUE_;
-        if (pba->has_scf == _TRUE_)
-          ppt->has_source_theta_scf = _TRUE_;
+	/*New EDE Ignore contributioin of trigger field */
+	if (pba->has_scf == _TRUE_)
+	  ppt->has_source_theta_scf = _TRUE_;
         if (pba->has_ur == _TRUE_)
           ppt->has_source_theta_ur = _TRUE_;
+	
+	if (pba->has_EDE_pert == _TRUE_)
+          ppt->has_source_theta_EDE = _TRUE_;
+	
         if (pba->has_idr == _TRUE_)
           ppt->has_source_theta_idr = _TRUE_;
         if (pba->has_idm_dr == _TRUE_)
@@ -1257,6 +1277,8 @@ int perturb_indices_of_perturbs(
       class_define_index(ppt->index_tp_delta_scf,  ppt->has_source_delta_scf, index_type,1);
       class_define_index(ppt->index_tp_delta_dr,   ppt->has_source_delta_dr,  index_type,1);
       class_define_index(ppt->index_tp_delta_ur,   ppt->has_source_delta_ur,  index_type,1);
+      class_define_index(ppt->index_tp_delta_EDE,  ppt->has_source_delta_EDE, index_type,1); 
+      class_define_index(ppt->index_tp_theta_EDE,  ppt->has_source_theta_EDE, index_type,1);
       class_define_index(ppt->index_tp_delta_idr,  ppt->has_source_delta_idr, index_type,1);
       class_define_index(ppt->index_tp_delta_idm_dr,  ppt->has_source_delta_idm_dr, index_type,1);
       class_define_index(ppt->index_tp_delta_ncdm1,ppt->has_source_delta_ncdm,index_type,pba->N_ncdm);
@@ -2577,6 +2599,8 @@ int perturb_workspace_init(
     class_define_index(ppw->index_ap_ncdmfa,pba->has_ncdm,index_ap,1);
     class_define_index(ppw->index_ap_tca_idm_dr,pba->has_idm_dr,index_ap,1);
     class_define_index(ppw->index_ap_rsa_idr,pba->has_idr,index_ap,1);
+    class_define_index(ppw->index_ap_CCa,pba->has_EDE_pert,index_ap,1);
+    class_define_index(ppw->index_ap_sda,pba->has_EDE_pert,index_ap,1); 
 
   }
 
@@ -2605,6 +2629,15 @@ int perturb_workspace_init(
     if (pba->has_ncdm == _TRUE_) {
       ppw->approx[ppw->index_ap_ncdmfa]=(int)ncdmfa_off;
     }
+
+     /*New EDE: Define CC approximation*/
+    if (pba->has_EDE_pert == _TRUE_) {
+      ppw->approx[ppw->index_ap_CCa]=(int)CCa_on;
+    }
+
+    if (pba->has_EDE_pert == _TRUE_) {
+      ppw->approx[ppw->index_ap_sda]=(int)sda_off;
+    }
   }
 
   if (_tensors_) {
@@ -3122,6 +3155,11 @@ int perturb_prepare_k_output(struct background * pba,
       class_store_columntitle(ppt->scalar_titles,"delta_ur",pba->has_ur);
       class_store_columntitle(ppt->scalar_titles,"theta_ur",pba->has_ur);
       class_store_columntitle(ppt->scalar_titles,"shear_ur",pba->has_ur);
+      /* New EDE*/
+      class_store_columntitle(ppt->scalar_titles,"delta_EDE",pba->has_EDE_pert);
+      class_store_columntitle(ppt->scalar_titles,"theta_EDE",pba->has_EDE_pert);
+      class_store_columntitle(ppt->scalar_titles,"shear_EDE",pba->has_EDE_pert);
+
       /* Interacting dark radiation */
       class_store_columntitle(ppt->scalar_titles,"delta_idr",pba->has_idr);
       class_store_columntitle(ppt->scalar_titles,"theta_idr",pba->has_idr);
@@ -3532,6 +3570,17 @@ int perturb_find_approximation_switches(
               fprintf(stdout,"Mode k=%e: will switch on ur fluid approximation at tau=%e\n",k,interval_limit[index_switch]);
             }
           }
+
+	  /*New EDE*/
+	  
+	  if (pba->has_EDE_pert == _TRUE_) {
+	    /*Here we check when the CC approximation is turned off*/
+	    if ((interval_approx[index_switch-1][ppw->index_ap_CCa]==(int)CCa_on) &&
+                (interval_approx[index_switch][ppw->index_ap_CCa]==(int)CCa_off)) {
+              fprintf(stdout,"Mode k=%e: will switch off CC approximation at tau=%e\n",k,interval_limit[index_switch]);
+	    }
+	  }
+	  
           if (pba->has_ncdm == _TRUE_) {
             if ((interval_approx[index_switch-1][ppw->index_ap_ncdmfa]==(int)ncdmfa_off) &&
                 (interval_approx[index_switch][ppw->index_ap_ncdmfa]==(int)ncdmfa_on)) {
@@ -3637,6 +3686,12 @@ int perturb_vector_init(
   int l;
   int n_ncdm,index_q,ncdm_l_size;
   double rho_plus_p_ncdm,q,q2,epsilon,a,factor;
+  /*New EDE*/
+  double amp_rel = 0.; 
+  double delta_rho_scf;
+  double rho_plus_p_theta_scf;
+  double a_prime_over_a;
+  double  delta_phi_over_phi_prime, sigma_EDE;
 
   /** - allocate a new perturb_vector structure to which ppw-->pv will point at the end of the routine */
 
@@ -3747,9 +3802,15 @@ int perturb_vector_init(
 
     /* scalar field */
 
-    class_define_index(ppv->index_pt_phi_scf,pba->has_scf,index_pt,1); /* scalar field density */
-    class_define_index(ppv->index_pt_phi_prime_scf,pba->has_scf,index_pt,1); /* scalar field velocity */
+    /*New EDE: Only track perturbations in clock field  before decay, afterwards they are irrelevant  */
 
+    if (pba->has_scf == _TRUE_){
+      if (pba->has_EDE_pert && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)){
+	class_define_index(ppv->index_pt_phi_scf,pba->has_scf,index_pt,1); /* scalar field density */
+	class_define_index(ppv->index_pt_phi_prime_scf,pba->has_scf,index_pt,1); /* scalar field velocity */
+      }
+    }
+    
     /* perturbed recombination: the indices are defined once tca is off. */
     if ( (ppt->has_perturbed_recombination == _TRUE_) && (ppw->approx[ppw->index_ap_tca] == (int)tca_off) ){
       class_define_index(ppv->index_pt_perturbed_recombination_delta_temp,_TRUE_,index_pt,1);
@@ -3770,6 +3831,16 @@ int perturb_vector_init(
       }
     }
 
+    /*New EDE*/
+    /*Here we allocate memory for the variables to be integrated depending on approximation scheme.*/
+    if (pba->has_EDE_pert  && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_off) && (ppw->approx[ppw->index_ap_sda] == (int)sda_off)  ) {
+
+      class_define_index(ppv->index_pt_delta_EDE,_TRUE_,index_pt,1); 
+      class_define_index(ppv->index_pt_theta_EDE,_TRUE_,index_pt,1); 
+      class_define_index(ppv->index_pt_shear_EDE,_TRUE_,index_pt,1); 
+    }
+    
+    
     /* interacting dark radiation */
 
     if (pba->has_idr == _TRUE_){
@@ -4084,6 +4155,16 @@ int perturb_vector_init(
 
       }
 
+      /*New EDE*/ /*Check that all modes are being initizalized before the transition*/
+      
+      if (pba->has_EDE_pert == _TRUE_) {
+
+        class_test(ppw->approx[ppw->index_ap_CCa] == (int)CCa_off,
+                   ppt->error_message,
+                   "scalar initial conditions assume EDE CC approximation turned on");
+
+      }
+
       if (pba->has_ncdm == _TRUE_) {
 
         class_test(ppw->approx[ppw->index_ap_ncdmfa] == (int)ncdmfa_on,
@@ -4215,14 +4296,14 @@ int perturb_vector_init(
         }
       }
 
-      if (pba->has_scf == _TRUE_) {
+      //if (pba->has_scf == _TRUE_) {
 
-        ppv->y[ppv->index_pt_phi_scf] =
-          ppw->pv->y[ppw->pv->index_pt_phi_scf];
+      //ppv->y[ppv->index_pt_phi_scf] =
+      //  ppw->pv->y[ppw->pv->index_pt_phi_scf];
 
-        ppv->y[ppv->index_pt_phi_prime_scf] =
-          ppw->pv->y[ppw->pv->index_pt_phi_prime_scf];
-      }
+      //ppv->y[ppv->index_pt_phi_prime_scf] =
+      //  ppw->pv->y[ppw->pv->index_pt_phi_prime_scf];
+      // }
 
       if (ppt->gauge == synchronous)
         ppv->y[ppv->index_pt_eta] =
@@ -4311,6 +4392,37 @@ int perturb_vector_init(
           }
         }
 
+
+	
+	/*New EDE*/
+	/*EDE perturbations not affectecd by tight coupling approximation, so we just copy the values from the previous integration step*/
+	if (pba->has_EDE_pert == _TRUE_ ) {
+	  if  ( (ppw->approx[ppw->index_ap_sda] == (int)sda_off) && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_off)){
+	    ppv->y[ppv->index_pt_delta_EDE] =
+	      ppw->pv->y[ppw->pv->index_pt_delta_EDE];
+
+	    ppv->y[ppv->index_pt_theta_EDE] =
+	      ppw->pv->y[ppw->pv->index_pt_theta_EDE];
+
+	    ppv->y[ppv->index_pt_shear_EDE] =
+	      ppw->pv->y[ppw->pv->index_pt_shear_EDE];
+	  }
+	}
+
+	 /*New EDE*/ /*scalar field not affected by this approximation scheme switch*/
+	if (pba->has_scf == _TRUE_) {
+	  if ((pba->has_EDE_pert) && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on) ){
+	  
+	    ppv->y[ppv->index_pt_phi_scf] =
+	      ppw->pv->y[ppw->pv->index_pt_phi_scf];
+	    
+	    ppv->y[ppv->index_pt_phi_prime_scf] =
+	      ppw->pv->y[ppw->pv->index_pt_phi_prime_scf];
+	  }
+	}
+
+
+
         if (pba->has_ncdm == _TRUE_) {
           index_pt = 0;
           for(n_ncdm = 0; n_ncdm < ppv->N_ncdm; n_ncdm++){
@@ -4393,6 +4505,34 @@ int perturb_vector_init(
             }
           }
         }
+	/*New EDE*/
+	/*EDE perturbations not affectecd by radiation streaming approximation, so we just copy the values from the previous integration step*/
+	if (pba->has_EDE_pert == _TRUE_ ) {
+	  if  ( (ppw->approx[ppw->index_ap_sda] == (int)sda_off) &&(ppw->approx[ppw->index_ap_CCa] == (int)CCa_off)){
+	    ppv->y[ppv->index_pt_delta_EDE] =
+	      ppw->pv->y[ppw->pv->index_pt_delta_EDE];
+
+	    ppv->y[ppv->index_pt_theta_EDE] =
+	      ppw->pv->y[ppw->pv->index_pt_theta_EDE];
+
+	    ppv->y[ppv->index_pt_shear_EDE] =
+	      ppw->pv->y[ppw->pv->index_pt_shear_EDE];
+	  }
+	}
+      
+
+       /*New EDE*/ /*scalar field not affected by this approximation scheme switch*/
+	if (pba->has_scf == _TRUE_) {
+	  if (pba->has_EDE_pert && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)){
+	  
+	    ppv->y[ppv->index_pt_phi_scf] =
+	      ppw->pv->y[ppw->pv->index_pt_phi_scf];
+	    
+	    ppv->y[ppv->index_pt_phi_prime_scf] =
+	      ppw->pv->y[ppw->pv->index_pt_phi_prime_scf];
+	  }
+	}
+
       }
 
       /* -- case of switching on ur fluid
@@ -4489,6 +4629,35 @@ int perturb_vector_init(
             }
           }
 
+
+	  	  /*New EDE*/
+	  /*Just copy values*/
+	  if (pba->has_EDE_pert == _TRUE_){
+	    if ((ppw->approx[ppw->index_ap_sda] == (int)sda_off) && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_off)) {
+
+	      ppv->y[ppv->index_pt_delta_EDE] =
+		ppw->pv->y[ppw->pv->index_pt_delta_EDE];
+
+	      ppv->y[ppv->index_pt_theta_EDE] =
+		ppw->pv->y[ppw->pv->index_pt_theta_EDE];
+
+	      ppv->y[ppv->index_pt_shear_EDE] =
+		ppw->pv->y[ppw->pv->index_pt_shear_EDE];
+	    }
+	  }
+
+	  if (pba->has_scf == _TRUE_) {
+	    if (pba->has_EDE_pert && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)){
+	  
+	      ppv->y[ppv->index_pt_phi_scf] =
+		ppw->pv->y[ppw->pv->index_pt_phi_scf];
+	    
+	      ppv->y[ppv->index_pt_phi_prime_scf] =
+		ppw->pv->y[ppw->pv->index_pt_phi_prime_scf];
+	    }
+	  }
+
+
           if (pba->has_ncdm == _TRUE_) {
             index_pt = 0;
             for(n_ncdm = 0; n_ncdm < ppv->N_ncdm; n_ncdm++){
@@ -4506,6 +4675,257 @@ int perturb_vector_init(
         }
       }
 
+
+
+      /*New EDE*/
+      /*Here we switch off the CC approximation / requires us to set initial conditions for all our modes / note that all other sectors are unaffected / this is quite crucial*/
+      if (pba->has_EDE_pert == _TRUE_) {
+
+        if ((pa_old[ppw->index_ap_CCa] == (int)CCa_on) && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_off)) {
+
+          if (ppt->perturbations_verbose>2)
+            fprintf(stdout,"Mode k=%e: switch off EDE CC approximation at tau=%e\n",k,tau);
+
+          if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {
+
+            ppv->y[ppv->index_pt_delta_g] =
+              ppw->pv->y[ppw->pv->index_pt_delta_g];
+
+            ppv->y[ppv->index_pt_theta_g] =
+              ppw->pv->y[ppw->pv->index_pt_theta_g];
+          }
+
+          if ((ppw->approx[ppw->index_ap_tca] == (int)tca_off) && (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off)) {
+
+            ppv->y[ppv->index_pt_shear_g] =
+              ppw->pv->y[ppw->pv->index_pt_shear_g];
+
+            ppv->y[ppv->index_pt_l3_g] =
+              ppw->pv->y[ppw->pv->index_pt_l3_g];
+
+            for (l = 4; l <= ppw->pv->l_max_g; l++) {
+
+              ppv->y[ppv->index_pt_delta_g+l] =
+                ppw->pv->y[ppw->pv->index_pt_delta_g+l];
+            }
+
+            ppv->y[ppv->index_pt_pol0_g] =
+              ppw->pv->y[ppw->pv->index_pt_pol0_g];
+
+            ppv->y[ppv->index_pt_pol1_g] =
+              ppw->pv->y[ppw->pv->index_pt_pol1_g];
+
+            ppv->y[ppv->index_pt_pol2_g] =
+              ppw->pv->y[ppw->pv->index_pt_pol2_g];
+
+            ppv->y[ppv->index_pt_pol3_g] =
+              ppw->pv->y[ppw->pv->index_pt_pol3_g];
+
+            for (l = 4; l <= ppw->pv->l_max_pol_g; l++) {
+
+              ppv->y[ppv->index_pt_pol0_g+l] =
+                ppw->pv->y[ppw->pv->index_pt_pol0_g+l];
+            }
+
+          }
+
+	  if (pba->has_ur == _TRUE_) {
+
+            if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {
+
+
+              ppv->y[ppv->index_pt_delta_ur] =
+                ppw->pv->y[ppw->pv->index_pt_delta_ur];
+
+              ppv->y[ppv->index_pt_theta_ur] =
+                ppw->pv->y[ppw->pv->index_pt_theta_ur];
+
+              ppv->y[ppv->index_pt_shear_ur] =
+                ppw->pv->y[ppw->pv->index_pt_shear_ur];
+
+              if (ppw->approx[ppw->index_ap_ufa] == (int)ufa_off) {
+
+                ppv->y[ppv->index_pt_l3_ur] =
+                  ppw->pv->y[ppw->pv->index_pt_l3_ur];
+
+                for (l=4; l <= ppv->l_max_ur; l++)
+                  ppv->y[ppv->index_pt_delta_ur+l] =
+                    ppw->pv->y[ppw->pv->index_pt_delta_ur+l];
+              }
+            }
+          }
+	  /*New EDE*/ /*important*/
+	  /*here we set the matching conditions for EDE perturbations: before transition perturbations are zero and after transition they start with value set by fluctuation in transition surface / see Israel's equations*/
+	  
+	  if ((ppw->approx[ppw->index_ap_sda] == (int)sda_off)){
+	    
+     
+	    a = ppw->pvecback[pba->index_bg_a];
+
+	  
+
+	    a_prime_over_a = ppw->pvecback[pba->index_bg_H]*a;
+	  
+	    if (pba->has_scf == _TRUE_) 
+	      delta_phi_over_phi_prime = ppw->pv->y[ppw->pv->index_pt_phi_scf] / (ppw->pvecback[pba->index_bg_phi_prime_scf] );
+	    else
+	      delta_phi_over_phi_prime = 0; //In absence of scalar field we use trivial junction conditions.  
+	  
+	    if (pba->Junction_tag == 0){
+	      amp_rel = 0.0;
+	      sigma_EDE = 0.0;
+	    }
+	    else if(pba->Junction_tag == 1){
+	      amp_rel = 1.;
+	      sigma_EDE = 0.0;
+	    }
+
+	  //printf("k: %f, aH: %f, h': %f, eta': %f, alpha1: %f, alpha2: %f \n",k,a_prime_over_a ,ppw->pvecmetric[ppw->index_mt_h_prime],ppw->pvecmetric[ppw->index_mt_eta_prime],(ppw->pvecmetric[ppw->index_mt_h_prime] + 6.0*ppw->pvecmetric[ppw->index_mt_eta_prime])/(2.0 *k*k),ppw->pvecmetric[ppw->index_mt_alpha]);
+	  
+	  	    
+	    ppv->y[ppv->index_pt_delta_EDE] =  - (3. + pba->three_eos_EDE) * amp_rel * a_prime_over_a * delta_phi_over_phi_prime;  // follows from junction conditions
+
+	    
+	    ppv->y[ppv->index_pt_theta_EDE] = - 1./(3. + pba->three_eos_EDE) * k * k / a_prime_over_a * ppv->y[ppv->index_pt_delta_EDE]; // follows from junction conditions
+
+
+	  // if (k<0.04 && k>0.03)
+	  //printf("v1: %f, v2: %f, v3: %E",k,ppw->pv->y[ppw->pv->index_pt_phi_scf], ppw->pvecback[pba->index_bg_phi_prime_scf]);
+		  
+	    // printf("z: %f and k: %f and delta_EDE: %f and theta_EDE: %f \n",1./a-1,k,ppv->y[ppv->index_pt_delta_EDE],ppv->y[ppv->index_pt_theta_EDE]);
+
+	    ppv->y[ppv->index_pt_shear_EDE] =  sigma_EDE;
+	    
+	    //the higher multipoles below we have to set to zero as they are not fixed by the junction conditions. Note that this is a gauge invariant choice.	
+	    
+	  }
+
+	  /* New EDE */ /*Scalar field evolution stops at transition.*/
+	  //  if (pba->has_scf == _TRUE_) {
+	  //if (pba->has_EDE_pert && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)){
+	  
+	  //  ppv->y[ppv->index_pt_phi_scf] =
+	  //	ppw->pv->y[ppw->pv->index_pt_phi_scf];
+	    
+	  //  ppv->y[ppv->index_pt_phi_prime_scf] =
+	  //	ppw->pv->y[ppw->pv->index_pt_phi_prime_scf];
+	  //}
+	  //}
+	  
+	  
+	  
+          if (pba->has_ncdm == _TRUE_) {
+            index_pt = 0;
+            for(n_ncdm = 0; n_ncdm < ppv->N_ncdm; n_ncdm++){
+              for(index_q=0; index_q < ppv->q_size_ncdm[n_ncdm]; index_q++){
+                for(l=0; l<=ppv->l_max_ncdm[n_ncdm]; l++){
+                  /* This is correct even when ncdmfa == off, since ppv->l_max_ncdm and
+                      ppv->q_size_ncdm is updated.*/
+                  ppv->y[ppv->index_pt_psi0_ncdm1+index_pt] =
+                    ppw->pv->y[ppw->pv->index_pt_psi0_ncdm1+index_pt];
+                  index_pt++;
+                }
+              }
+            }
+          }
+        }
+
+	if ((pa_old[ppw->index_ap_sda] == (int)sda_off) && (ppw->approx[ppw->index_ap_sda] == (int)sda_on)) {
+
+          if (ppt->perturbations_verbose>2)
+            fprintf(stdout,"Mode k=%e: switch off EDE CC approximation at tau=%e\n",k,tau);
+
+          if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {
+
+            ppv->y[ppv->index_pt_delta_g] =
+              ppw->pv->y[ppw->pv->index_pt_delta_g];
+
+            ppv->y[ppv->index_pt_theta_g] =
+              ppw->pv->y[ppw->pv->index_pt_theta_g];
+          }
+
+          if ((ppw->approx[ppw->index_ap_tca] == (int)tca_off) && (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off)) {
+
+            ppv->y[ppv->index_pt_shear_g] =
+              ppw->pv->y[ppw->pv->index_pt_shear_g];
+
+            ppv->y[ppv->index_pt_l3_g] =
+              ppw->pv->y[ppw->pv->index_pt_l3_g];
+
+            for (l = 4; l <= ppw->pv->l_max_g; l++) {
+
+              ppv->y[ppv->index_pt_delta_g+l] =
+                ppw->pv->y[ppw->pv->index_pt_delta_g+l];
+            }
+
+            ppv->y[ppv->index_pt_pol0_g] =
+              ppw->pv->y[ppw->pv->index_pt_pol0_g];
+
+            ppv->y[ppv->index_pt_pol1_g] =
+              ppw->pv->y[ppw->pv->index_pt_pol1_g];
+
+            ppv->y[ppv->index_pt_pol2_g] =
+              ppw->pv->y[ppw->pv->index_pt_pol2_g];
+
+            ppv->y[ppv->index_pt_pol3_g] =
+              ppw->pv->y[ppw->pv->index_pt_pol3_g];
+
+            for (l = 4; l <= ppw->pv->l_max_pol_g; l++) {
+
+              ppv->y[ppv->index_pt_pol0_g+l] =
+                ppw->pv->y[ppw->pv->index_pt_pol0_g+l];
+            }
+
+          }
+
+	  if (pba->has_ur == _TRUE_) {
+
+            if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {
+
+
+              ppv->y[ppv->index_pt_delta_ur] =
+                ppw->pv->y[ppw->pv->index_pt_delta_ur];
+
+              ppv->y[ppv->index_pt_theta_ur] =
+                ppw->pv->y[ppw->pv->index_pt_theta_ur];
+
+              ppv->y[ppv->index_pt_shear_ur] =
+                ppw->pv->y[ppw->pv->index_pt_shear_ur];
+
+              if (ppw->approx[ppw->index_ap_ufa] == (int)ufa_off) {
+
+                ppv->y[ppv->index_pt_l3_ur] =
+                  ppw->pv->y[ppw->pv->index_pt_l3_ur];
+
+                for (l=4; l <= ppv->l_max_ur; l++)
+                  ppv->y[ppv->index_pt_delta_ur+l] =
+                    ppw->pv->y[ppw->pv->index_pt_delta_ur+l];
+              }
+            }
+          }
+	  
+	  
+          if (pba->has_ncdm == _TRUE_) {
+            index_pt = 0;
+            for(n_ncdm = 0; n_ncdm < ppv->N_ncdm; n_ncdm++){
+              for(index_q=0; index_q < ppv->q_size_ncdm[n_ncdm]; index_q++){
+                for(l=0; l<=ppv->l_max_ncdm[n_ncdm]; l++){
+                  /* This is correct even when ncdmfa == off, since ppv->l_max_ncdm and
+                      ppv->q_size_ncdm is updated.*/
+                  ppv->y[ppv->index_pt_psi0_ncdm1+index_pt] =
+                    ppw->pv->y[ppw->pv->index_pt_psi0_ncdm1+index_pt];
+                  index_pt++;
+                }
+              }
+            }
+          }
+        }
+
+	
+      }
+
+
+      
       /* Case of switching on rsa for interacting dark radiation */
       if (pba->has_idr == _TRUE_) {
         if ((pa_old[ppw->index_ap_rsa_idr] == (int)rsa_idr_off) && (ppw->approx[ppw->index_ap_rsa_idr] == (int)rsa_idr_on)) {
@@ -4695,6 +5115,37 @@ int perturb_vector_init(
             }
           }
 
+
+	  	  	  /*New EDE*/
+	  /*Just copy values*/
+	  if (pba->has_EDE_pert == _TRUE_){
+	    if ((ppw->approx[ppw->index_ap_sda] == (int)sda_off)&&(ppw->approx[ppw->index_ap_CCa] == (int)CCa_off)) {
+
+	      ppv->y[ppv->index_pt_delta_EDE] =
+		ppw->pv->y[ppw->pv->index_pt_delta_EDE];
+
+	      ppv->y[ppv->index_pt_theta_EDE] =
+		ppw->pv->y[ppw->pv->index_pt_theta_EDE];
+
+	      ppv->y[ppv->index_pt_shear_EDE] =
+		ppw->pv->y[ppw->pv->index_pt_shear_EDE];
+	    }
+	  }
+
+	  if (pba->has_scf == _TRUE_) {
+	    if (pba->has_EDE_pert && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)){
+	  
+	      ppv->y[ppv->index_pt_phi_scf] =
+		ppw->pv->y[ppw->pv->index_pt_phi_scf];
+	    
+	      ppv->y[ppv->index_pt_phi_prime_scf] =
+		ppw->pv->y[ppw->pv->index_pt_phi_prime_scf];
+	    }
+	  }
+
+
+	  
+
           if (pba->has_ncdm == _TRUE_) {
             index_pt = 0;
             for(n_ncdm = 0; n_ncdm < ppv->N_ncdm; n_ncdm++){
@@ -4793,6 +5244,35 @@ int perturb_vector_init(
             }
           }
 
+
+	  	  	  /*New EDE*/
+	  /*Just copy values*/
+	  if (pba->has_EDE_pert == _TRUE_){
+	    if ((ppw->approx[ppw->index_ap_sda] == (int)sda_off)&&(ppw->approx[ppw->index_ap_CCa] == (int)CCa_off)) {
+
+	      ppv->y[ppv->index_pt_delta_EDE] =
+		ppw->pv->y[ppw->pv->index_pt_delta_EDE];
+
+	      ppv->y[ppv->index_pt_theta_EDE] =
+		ppw->pv->y[ppw->pv->index_pt_theta_EDE];
+
+	      ppv->y[ppv->index_pt_shear_EDE] =
+		ppw->pv->y[ppw->pv->index_pt_shear_EDE];
+	    }
+	  }
+
+	  if (pba->has_scf == _TRUE_) {
+	    if (pba->has_EDE_pert && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)){
+	  
+	      ppv->y[ppv->index_pt_phi_scf] =
+		ppw->pv->y[ppw->pv->index_pt_phi_scf];
+	    
+	      ppv->y[ppv->index_pt_phi_prime_scf] =
+		ppw->pv->y[ppw->pv->index_pt_phi_prime_scf];
+	    }
+	  }
+
+
           if (pba->has_idr == _TRUE_){
             if (ppw->approx[ppw->index_ap_rsa_idr] == (int)rsa_idr_off){
 
@@ -5145,6 +5625,17 @@ int perturb_initial_conditions(struct precision * ppr,
       rho_nu += ppw->pvecback[pba->index_bg_rho_ur];
     }
 
+    /*New EDE*/
+    /*Check if we need to include something here. I don't think so, because at early times EDE is not behaving like radiation.*/ /*Actually, we do need to include something here, only if intial time is set after decay has taken place*/
+    if (pba->has_EDE_pert == _TRUE_) {
+      //printf("(z: %f, k: %f )",1/a-1,k);	
+      if (pba->z_decay > 1/a-1){
+	
+	rho_r += ppw->pvecback[pba->index_bg_rho_EDE2];
+	rho_nu += ppw->pvecback[pba->index_bg_rho_EDE2];
+      }
+    }
+
     if (pba->has_idr == _TRUE_) {
       rho_r += ppw->pvecback[pba->index_bg_rho_idr];
       rho_nu += ppw->pvecback[pba->index_bg_rho_idr];
@@ -5260,7 +5751,9 @@ int perturb_initial_conditions(struct precision * ppr,
         /* if use_ppf == _TRUE_, y[ppw->pv->index_pt_Gamma_fld] will be automatically set to zero, and this is what we want (although one could probably work out some small nonzero initial conditions: TODO) */
       }
 
-      if (pba->has_scf == _TRUE_) {
+      if ((pba->has_scf == _TRUE_) && (pba->has_EDE_pert == _TRUE_)){
+	if ( (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)) {
+
         /** - ---> Canonical field (solving for the perturbations):
          *  initial perturbations set to zero, they should reach the attractor soon enough.
          *  - --->  TODO: Incorporate the attractor IC from 1004.5509.
@@ -5269,13 +5762,17 @@ int perturb_initial_conditions(struct precision * ppr,
          *  and assume theta, delta_rho as for perfect fluid
          *  with \f$ c_s^2 = 1 \f$ and w = 1/3 (ASSUMES radiation TRACKING)
          */
-
-        ppw->pv->y[ppw->pv->index_pt_phi_scf] = 0.;
+	/*New EDE*/ /*We set perturbations on the adiabatic attractor solution*/
+	
+	  ppw->pv->y[ppw->pv->index_pt_phi_scf] = pba->EDE2_clock_pert_ini * (1. - 1./6.*k*k/pow(a * ppw->pvecback[pba->index_bg_H],2) - 1./20.* pow(pba->EDE2_clock_mass / ppw->pvecback[pba->index_bg_H],2) ) - 1./140. * pba->phi_ini_scf * ppw->pv->y[ppw->pv->index_pt_delta_g] * pow(pba->EDE2_clock_mass / ppw->pvecback[pba->index_bg_H],2) ;
         /*  a*a/k/k/ppw->pvecback[pba->index_bg_phi_prime_scf]*k*ktau_three/4.*1./(4.-6.*(1./3.)+3.*1.) * (ppw->pvecback[pba->index_bg_rho_scf] + ppw->pvecback[pba->index_bg_p_scf])* ppr->curvature_ini * s2_squared; */
 
-        ppw->pv->y[ppw->pv->index_pt_phi_prime_scf] = 0.;
+	  ppw->pv->y[ppw->pv->index_pt_phi_prime_scf] = pba->EDE2_clock_pert_ini * (- 1./3.*k*k/(a * ppw->pvecback[pba->index_bg_H]) - 1./5.* pow(pba->EDE2_clock_mass,2) * a / ppw->pvecback[pba->index_bg_H] ) - 3/70 * pba->phi_ini_scf * ppw->pv->y[ppw->pv->index_pt_delta_g]*pow(pba->EDE2_clock_mass, 2) * a / ppw->pvecback[pba->index_bg_H] ;
         /* delta_fld expression * rho_scf with the w = 1/3, c_s = 1
-           a*a/ppw->pvecback[pba->index_bg_phi_prime_scf]*( - ktau_two/4.*(1.+1./3.)*(4.-3.*1.)/(4.-6.*(1/3.)+3.*1.)*ppw->pvecback[pba->index_bg_rho_scf] - ppw->pvecback[pba->index_bg_dV_scf]*ppw->pv->y[ppw->pv->index_pt_phi_scf])* ppr->curvature_ini * s2_squared; */
+            a*a/ppw->pvecback[pba->index_bg_phi_prime_scf]*( - ktau_two/4.*(1.+1./3.)*(4.-3.*1.)/(4.-6.*(1/3.)+3.*1.)*ppw->pvecback[pba->index_bg_rho_scf] - ppw->pvecback[pba->index_bg_dV_scf]*ppw->pv->y[ppw->pv->index_pt_phi_scf])* ppr->curvature_ini * s2_squared; */
+
+
+	}
       }
 
       /* all relativistic relics: ur, early ncdm, dr */
@@ -5521,17 +6018,22 @@ int perturb_initial_conditions(struct precision * ppr,
         ppw->pv->y[ppw->pv->index_pt_theta_fld] += k*k*alpha;
       }
 
+      /*New EDE*/ /*Not important*/
       /* scalar field: check */
       if (pba->has_scf == _TRUE_) {
-        alpha_prime = 0.0;
-        /* - 2. * a_prime_over_a * alpha + eta
-           - 4.5 * (a2/k2) * ppw->rho_plus_p_shear; */
-
-        ppw->pv->y[ppw->pv->index_pt_phi_scf] += alpha*ppw->pvecback[pba->index_bg_phi_prime_scf];
-        ppw->pv->y[ppw->pv->index_pt_phi_prime_scf] +=
-          (-2.*a_prime_over_a*alpha*ppw->pvecback[pba->index_bg_phi_prime_scf]
-           -a*a* dV_scf(pba,ppw->pvecback[pba->index_bg_phi_scf])*alpha
-           +ppw->pvecback[pba->index_bg_phi_prime_scf]*alpha_prime);
+	if ((pba->has_EDE_pert == _TRUE_) && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)){
+	
+	  alpha_prime = 0.0;
+      
+          /* - 2. * a_prime_over_a * alpha + eta
+             - 4.5 * (a2/k2) * ppw->rho_plus_p_shear; */
+
+	  ppw->pv->y[ppw->pv->index_pt_phi_scf] += alpha*ppw->pvecback[pba->index_bg_phi_prime_scf];
+	  ppw->pv->y[ppw->pv->index_pt_phi_prime_scf] +=
+	    (-2.*a_prime_over_a*alpha*ppw->pvecback[pba->index_bg_phi_prime_scf]
+	     -a*a* dV_scf(pba,ppw->pvecback[pba->index_bg_phi_scf])*alpha
+	     +ppw->pvecback[pba->index_bg_phi_prime_scf]*alpha_prime);
+	}
       }
 
       if ((pba->has_ur == _TRUE_) || (pba->has_ncdm == _TRUE_) || (pba->has_dr == _TRUE_)  || (pba->has_idr == _TRUE_)) {
@@ -5919,6 +6421,31 @@ int perturb_approximations(
       ppw->approx[ppw->index_ap_rsa] = (int)rsa_off;
     }
 
+
+    /*New EDE*/
+    /*define CC approximation / turned on at early times / turned off once EDE starts to decay*/
+    if (pba->has_EDE_pert == _TRUE_){
+      if (1./ppw->pvecback[pba->index_bg_a]-1. > pba->z_decay) {
+	ppw->approx[ppw->index_ap_CCa] = (int)CCa_on;
+      }
+      else {
+	ppw->approx[ppw->index_ap_CCa] = (int)CCa_off;
+      }
+      //printf("k: %e, app: %d \n",k, ppw->approx[ppw->index_ap_CCa]);
+    }
+
+    /*New EDE*/
+    /*define sd (sub dominant) approximation / turned on when after decay EDE becomes highly sub dominant and perturbations need not be tracked anymore (after decay!)*/
+    if (pba->has_EDE_pert == _TRUE_){
+      if ((1./ppw->pvecback[pba->index_bg_a]-1. < pba->z_decay*0.9) && (ppw->pvecback[pba->index_bg_rho_EDE2]/pow(ppw->pvecback[pba->index_bg_H],2)< ppr->sub_dom_cond )) {
+	ppw->approx[ppw->index_ap_sda] = (int)sda_on;
+      }
+      else {
+	ppw->approx[ppw->index_ap_sda] = (int)sda_off;
+      }
+      //printf("k: %e, app: %d \n",k, ppw->approx[ppw->index_ap_CCa]);
+    }
+
     /* interacting dark radiation free streaming approximation*/
     if (pba->has_idr == _TRUE_){
 
@@ -6461,6 +6988,12 @@ int perturb_total_stress_energy(
   double delta_ur=0.;
   double theta_ur=0.;
   double shear_ur=0.;
+  /*New EDE*/
+  double delta_EDE=0.;
+  double theta_EDE=0.;
+  double shear_EDE=0.;
+  
+  
   double delta_idr=0.;
   double theta_idr=0.;
   double shear_idr=0.;
@@ -6569,6 +7102,31 @@ int perturb_total_stress_energy(
 
     }
 
+    /*New EDE*/
+    /*Here the Einstein pert. equation is solved, requires the values of the matter sector*/
+    if (pba->has_EDE_pert == _TRUE_) {
+
+      if ((ppw->approx[ppw->index_ap_sda] == (int)sda_off) && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_off)) {
+
+        delta_EDE = y[ppw->pv->index_pt_delta_EDE];
+        theta_EDE = y[ppw->pv->index_pt_theta_EDE];
+        shear_EDE = y[ppw->pv->index_pt_shear_EDE];
+
+      }
+
+      else {
+
+        delta_EDE = 0.; /* actual free streaming approximation imposed after evaluation of 1st einstein equation */
+        theta_EDE = 0.; /* actual free streaming approximation imposed after evaluation of 1st einstein equation */
+        shear_EDE = 0.; /* shear always neglected in free streaming approximation */
+
+      }
+
+    }
+
+
+    
+
     /** - ---> (a.3.) baryon pressure perturbation */
 
     if ((ppt->has_perturbed_recombination == _TRUE_) &&(ppw->approx[ppw->index_ap_tca] == (int)tca_off)) {
@@ -6604,6 +7162,8 @@ int perturb_total_stress_energy(
       }
     }
 
+    
+
     /** - --> (b) compute the total density, velocity and shear perturbations */
 
     /* photon and baryon contribution */
@@ -6648,7 +7208,7 @@ int perturb_total_stress_energy(
     if (pba->has_idm_dr == _TRUE_) {
       ppw->delta_rho += ppw->pvecback[pba->index_bg_rho_idm_dr]*y[ppw->pv->index_pt_delta_idm_dr];
       ppw->rho_plus_p_theta += ppw->pvecback[pba->index_bg_rho_idm_dr]*y[ppw->pv->index_pt_theta_idm_dr];
-      rho_plus_p_tot += ppw->pvecback[pba->index_bg_rho_idm_dr];
+      ppw->rho_plus_p_tot += ppw->pvecback[pba->index_bg_rho_idm_dr];
     }
 
     /* dcdm contribution */
@@ -6703,7 +7263,7 @@ int perturb_total_stress_energy(
       if (ppt->idr_nature==idr_free_streaming)
         ppw->rho_plus_p_shear += 4./3.*ppw->pvecback[pba->index_bg_rho_idr]*shear_idr;
       ppw->delta_p += 1./3. * ppw->pvecback[pba->index_bg_rho_idr]*delta_idr;
-      rho_plus_p_tot += 4./3. * ppw->pvecback[pba->index_bg_rho_idr];
+      ppw->rho_plus_p_tot += 4./3. * ppw->pvecback[pba->index_bg_rho_idr];
     }
 
     /* infer delta_cb abd theta_cb (perturbations from CDM and baryons) before adding ncdm */
@@ -6714,7 +7274,27 @@ int perturb_total_stress_energy(
         ((ppt->has_source_delta_cb == _TRUE_) || (ppt->has_source_theta_cb == _TRUE_)))
       ppw->theta_cb = rho_plus_p_theta_m/rho_plus_p_m;
 
+    
+    /*New EDE*/ /*Change!!*/
+    /*Here everything is added up. Note that we excluded the CC phase as there are no contributions in that case. This part is important as it describes the feedback of the EDE pert. into the gravitational sector.*/
+    if ((pba->has_EDE_pert == _TRUE_) && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_off) && (ppw->approx[ppw->index_ap_sda] == (int)sda_off) ) {
+      ppw->delta_rho = ppw->delta_rho + ppw->pvecback[pba->index_bg_rho_EDE2]*delta_EDE; //checked
+      ppw->rho_plus_p_theta = ppw->rho_plus_p_theta + (1.+pba->three_eos_EDE/3.)*ppw->pvecback[pba->index_bg_rho_EDE2]*theta_EDE; //checked
+      ppw->rho_plus_p_shear = ppw->rho_plus_p_shear + (1.+pba->three_eos_EDE/3.)*ppw->pvecback[pba->index_bg_rho_EDE2]*shear_EDE; //checked
+      //ppw->delta_p += pba->three_eos_EDE/3.*ppw->pvecback[pba->index_bg_rho_EDE2]*delta_EDE; 
+      ppw->delta_p += ppt->three_ceff2_EDE/3. * ppw->pvecback[pba->index_bg_rho_EDE2]*delta_EDE + (ppt->three_ceff2_EDE/3. - pba->three_eos_EDE / 3.)*(3.*a_prime_over_a* ((1.+pba->three_eos_EDE/3.)*ppw->pvecback[pba->index_bg_rho_EDE2]*theta_EDE)/k/k);
+
+      /* This part is implemented overly correct as first case cannot happen*/
+      if ( 1. / a - 1.  > pba->z_decay) {
+	ppw->rho_plus_p_tot += 0.0;
+      }
+      else {
+	ppw->rho_plus_p_tot += (1. + pba->three_eos_EDE/3.) * ppw->pvecback[pba->index_bg_rho_EDE2]; //checked
+      }
+    }
+
 
+    
     /* non-cold dark matter contribution */
     if (pba->has_ncdm == _TRUE_) {
       idx = ppw->pv->index_pt_psi0_ncdm1;
@@ -6809,41 +7389,49 @@ int perturb_total_stress_energy(
        from rho_plus_p_shear. So the contribution from the scalar field must be below all
        species with non-zero shear.
     */
-    if (pba->has_scf == _TRUE_) {
 
-      if (ppt->gauge == synchronous){
-        delta_rho_scf =  1./3.*
-          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
-           + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]);
-        delta_p_scf = 1./3.*
-          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
-           - ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]);
-      }
-      else{
-        /* equation for psi */
-        psi = y[ppw->pv->index_pt_phi] - 4.5 * (a2/k/k) * ppw->rho_plus_p_shear;
 
-        delta_rho_scf =  1./3.*
-          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
-           + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
-           - 1./a2*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*psi);
-        delta_p_scf =  1./3.*
-          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
-           - ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
-           - 1./a2*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*psi);
-      }
+     /*New EDE*/ /*Tag3 This is the feedback of the scalar perturbation in the metric sector.*/
+    if ((pba->has_scf == _TRUE_) && (pba->has_EDE_pert == _TRUE_)  ){
+      if (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on) {
 
-      ppw->delta_rho += delta_rho_scf;
+	if (ppt->gauge == synchronous){ //Is factor 1./3. correct? I think so.
+	  delta_rho_scf =  1./3.*
+	    (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
+	     + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]);
+	  delta_p_scf = 1./3.*
+	    (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
+	     - ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]);
+	}
+	else{
+	  /* equation for psi */
+	  psi = y[ppw->pv->index_pt_phi] - 4.5 * (a2/k/k) * ppw->rho_plus_p_shear;
+	  
+	  delta_rho_scf =  1./3.*
+	    (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
+	     + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
+	     - 1./a2*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*psi);
+	  delta_p_scf =  1./3.*
+	    (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
+	     - ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
+	     - 1./a2*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*psi);
+	}
+	
+	
 
-      ppw->rho_plus_p_theta +=  1./3.*
-        k*k/a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_scf];
+	ppw->delta_rho += delta_rho_scf;
 
-      ppw->delta_p += delta_p_scf;
+	ppw->rho_plus_p_theta +=  1./3.*
+	  k*k/a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_scf];
 
-      ppw->rho_plus_p_tot += ppw->pvecback[pba->index_bg_rho_scf]+ppw->pvecback[pba->index_bg_p_scf];
+	ppw->delta_p += delta_p_scf;
 
+	ppw->rho_plus_p_tot += ppw->pvecback[pba->index_bg_rho_scf]+ppw->pvecback[pba->index_bg_p_scf];
+
+      }
     }
 
+
     /* add your extra species here */
 
     /* fluid contribution */
@@ -6916,8 +7504,8 @@ int perturb_total_stress_energy(
 	Z = 2./3.*k2*ppw->pvecback[pba->index_bg_H]/a;
 	Z_prime = Z*(ppw->pvecback[pba->index_bg_H_prime]/ppw->pvecback[pba->index_bg_H] - a_prime_over_a);
 	/** Construct theta_t and its derivative from the Euler equation */
-	theta_t = ppw->rho_plus_p_theta/rho_plus_p_tot;
-	theta_t_prime = -a_prime_over_a*theta_t-(p_t_prime*theta_t-k2*ppw->delta_p +k2*ppw->rho_plus_p_shear)/rho_plus_p_tot+metric_euler;
+	theta_t = ppw->rho_plus_p_theta/ppw->rho_plus_p_tot;
+	theta_t_prime = -a_prime_over_a*theta_t-(p_t_prime*theta_t-k2*ppw->delta_p +k2*ppw->rho_plus_p_shear)/ppw->rho_plus_p_tot+metric_euler;
 	S = ppw->S_fld;
 	S_prime = -Z_prime/Z*S+1./Z*(rho_fld_prime+p_fld_prime)*(theta_t+k2*alpha)+1./Z*(rho_fld+p_fld)*(theta_t_prime+k2*alpha_prime);
 	/** Analytic derivative of the equation for ppw->rho_plus_p_theta_fld above. */
@@ -7451,22 +8039,24 @@ int perturb_sources(
         + 3.*a_prime_over_a*(1.+pvecback[pba->index_bg_w_fld])*theta_over_k2; // N-body gauge correction
     }
 
-    /* delta_scf */
-    if (ppt->has_source_delta_scf == _TRUE_) {
-      if (ppt->gauge == synchronous){
-        delta_rho_scf =  1./3.*
-          (1./a2_rel*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
-           + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf])
-          + 3.*a_prime_over_a*(1.+pvecback[pba->index_bg_p_scf]/pvecback[pba->index_bg_rho_scf])*theta_over_k2; // N-body gauge correction
-      }
-      else{
-        delta_rho_scf =  1./3.*
-          (1./a2_rel*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
-           + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
-           - 1./a2_rel*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*ppw->pvecmetric[ppw->index_mt_psi])
-          + 3.*a_prime_over_a*(1.+pvecback[pba->index_bg_p_scf]/pvecback[pba->index_bg_rho_scf])*theta_over_k2; // N-body gauge correction
+    /*New EDE*/
+    if (pba->has_EDE_pert == _TRUE_ && pba->has_scf == _TRUE_){
+      if (ppt->has_source_delta_scf == _TRUE_) {
+	if((ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)){
+	  if (ppt->gauge == synchronous){
+	    delta_rho_scf =  1./3.*
+	      (1./a2_rel*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
+	       + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]);
+	  }
+	  else{
+	    delta_rho_scf =  1./3.*
+	      (1./a2_rel*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
+	       + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
+	       - 1./a2_rel*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*ppw->pvecmetric[ppw->index_mt_psi]);
+	  }
+	  _set_source_(ppt->index_tp_delta_scf) = delta_rho_scf/pvecback[pba->index_bg_rho_scf];
+	}	
       }
-      _set_source_(ppt->index_tp_delta_scf) = delta_rho_scf/pvecback[pba->index_bg_rho_scf];
     }
 
     /* delta_dr */
@@ -7486,6 +8076,15 @@ int perturb_sources(
           + 4.*a_prime_over_a*theta_over_k2; // N-body gauge correction
     }
 
+    /* New EDE */
+    /*This part is relevant if we calculate matter transfer function as needed for sigma8*/
+    if (ppt->has_source_delta_EDE == _TRUE_) {
+      if ((ppw->approx[ppw->index_ap_sda] == (int)sda_off) &&(ppw->approx[ppw->index_ap_CCa]==(int)CCa_off))
+        _set_source_(ppt->index_tp_delta_EDE) = y[ppw->pv->index_pt_delta_EDE];
+      else
+	_set_source_(ppt->index_tp_delta_EDE) = 0.0;
+    }
+
     /* delta_idr */
     if (ppt->has_source_delta_idr == _TRUE_) {
       if (ppw->approx[ppw->index_ap_rsa_idr]==(int)rsa_idr_off)
@@ -7577,15 +8176,22 @@ int perturb_sources(
     }
 
     /* theta_scf */
-    if (ppt->has_source_theta_scf == _TRUE_) {
-
-      rho_plus_p_theta_scf = 1./3.*
-        k*k/a2_rel*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_scf];
 
-      _set_source_(ppt->index_tp_theta_scf) = rho_plus_p_theta_scf/(pvecback[pba->index_bg_rho_scf]+pvecback[pba->index_bg_p_scf])
-        + theta_shift; // N-body gauge correction
+    /*New EDE*/
+    if ((pba->has_EDE_pert == _TRUE_) && pba->has_scf == _TRUE_){
+      if (ppt->has_source_theta_scf == _TRUE_) {
+	if(ppw->approx[ppw->index_ap_CCa] == (int)CCa_on){
+	  rho_plus_p_theta_scf = 1./3.*
+	    k*k/a2_rel*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_scf];
+	  _set_source_(ppt->index_tp_theta_scf) = rho_plus_p_theta_scf/
+	    (pvecback[pba->index_bg_rho_scf]+pvecback[pba->index_bg_p_scf]);
+	}
+	//else{
+	//_set_source_(ppt->index_tp_theta_scf) = 0.0;
+	//}
+      }
     }
-
+    
     /* theta_dr */
     if (ppt->has_source_theta_dr == _TRUE_) {
 
@@ -7605,6 +8211,16 @@ int perturb_sources(
           + theta_shift; // N-body gauge correction
     }
 
+    /*New EDE*/
+    /*same for theta*/
+    if (ppt->has_source_theta_EDE == _TRUE_) {
+      if ((ppw->approx[ppw->index_ap_sda]==(int)sda_off)&&(ppw->approx[ppw->index_ap_CCa]==(int)CCa_off))
+        _set_source_(ppt->index_tp_theta_EDE) = y[ppw->pv->index_pt_theta_EDE];
+      else
+	_set_source_(ppt->index_tp_theta_EDE) = 0.0;
+    }
+
+    
     /* theta_idr */
     if (ppt->has_source_theta_idr == _TRUE_) {
       if (ppw->approx[ppw->index_ap_rsa_idr]==(int)rsa_idr_off)
@@ -7718,6 +8334,7 @@ int perturb_print_variables(double tau,
   double delta_dcdm=0.,theta_dcdm=0.;
   double delta_dr=0.,theta_dr=0.,shear_dr=0., f_dr=1.0;
   double delta_ur=0.,theta_ur=0.,shear_ur=0.,l4_ur=0.;
+  double delta_EDE=0.,theta_EDE=0.,shear_EDE=0.;
   double delta_idr=0., theta_idr=0., shear_idr=0.;
   double delta_rho_scf=0., rho_plus_p_theta_scf=0.;
   double delta_scf=0., theta_scf=0.;
@@ -7859,6 +8476,25 @@ int perturb_print_variables(double tau,
       }
     }
 
+
+    /*New EDE*/
+    /* Here we infer the perturbations for different approximations in order to print them in a file*/
+    if (pba->has_EDE_pert == _TRUE_) {
+      if ((ppw->approx[ppw->index_ap_sda]==(int)sda_off)&&(ppw->approx[ppw->index_ap_CCa]==(int)CCa_off)) {
+        delta_EDE = y[ppw->pv->index_pt_delta_EDE];
+        theta_EDE = y[ppw->pv->index_pt_theta_EDE];
+        shear_EDE = y[ppw->pv->index_pt_shear_EDE];
+      }
+      else {
+        delta_EDE = 0.;
+        theta_EDE = 0.;
+        shear_EDE = 0.;
+      }
+    }
+
+
+    
+
     delta_b = y[ppw->pv->index_pt_delta_b];
     theta_b = y[ppw->pv->index_pt_theta_b];
 
@@ -7992,33 +8628,41 @@ int perturb_print_variables(double tau,
       shear_dr = y[ppw->pv->index_pt_F0_dr+2]*0.5/f_dr;
     }
 
-    if (pba->has_scf == _TRUE_){
-      if (ppt->gauge == synchronous){
-        delta_rho_scf =  1./3.*
-          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
-           + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]);
-      }
-      else{
-        delta_rho_scf =  1./3.*
-          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
-           + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
-           - 1./a2*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*ppw->pvecmetric[ppw->index_mt_psi]);
-      }
+        /*New EDE*/ /*To do: check!*/
 
-      rho_plus_p_theta_scf =  1./3.*
-        k*k/a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_scf];
+    if ((pba->has_scf == _TRUE_) && (pba->has_EDE_pert == _TRUE_)){
+    
+      if ( (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)){
+	if (ppt->gauge == synchronous){
+	  delta_rho_scf =  1./3.*
+	    (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
+	     + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]);
+	}
+	else{
+	  delta_rho_scf =  1./3.*
+	    (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
+	     + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
+	     - 1./a2*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*ppw->pvecmetric[ppw->index_mt_psi]);
+	}
 
-      delta_scf = delta_rho_scf/pvecback[pba->index_bg_rho_scf];
-      theta_scf = rho_plus_p_theta_scf/(pvecback[pba->index_bg_rho_scf]+pvecback[pba->index_bg_p_scf]);
+	rho_plus_p_theta_scf =  1./3.*
+	  k*k/a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_scf];
 
+	delta_scf = delta_rho_scf/pvecback[pba->index_bg_rho_scf];
+	theta_scf = rho_plus_p_theta_scf; ///(pvecback[pba->index_bg_rho_scf]+pvecback[pba->index_bg_p_scf]);
+	/*New EDE*/ /*Note non standard definition to avoid singularities*/	
+      }
     }
 
+
+    
+
     /* converting synchronous variables to newtonian ones */
     if (ppt->gauge == synchronous) {
 
       /* density and velocity perturbations (comment out if you wish to keep synchronous variables) */
 
-      delta_g -= 4. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
+      /*delta_g -= 4. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
       theta_g += k*k*alpha;
 
       delta_b -= 3. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
@@ -8027,7 +8671,18 @@ int perturb_print_variables(double tau,
       if (pba->has_ur == _TRUE_) {
         delta_ur -= 4. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
         theta_ur += k*k*alpha;
+	}*/
+
+            /*New EDE*/
+      /*Here we convert to Newtonian gauge, not really important for running of code but for plotting / Note that the conversion is only well-defined if the equation of state is not -1*/
+
+      /*
+      if ((pba->has_EDE_pert == _TRUE_) && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_off) ) {
+	delta_EDE -= 4. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
+        theta_EDE += k*k*alpha;
       }
+      */
+
 
       if (pba->has_idr == _TRUE_) {
         delta_idr -= 4. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
@@ -8039,11 +8694,11 @@ int perturb_print_variables(double tau,
 
         theta_dr += k*k*alpha;
       }
-
+      /*
       if (pba->has_cdm == _TRUE_) {
         delta_cdm -= 3. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
         theta_cdm += k*k*alpha;
-      }
+	}*/
 
       if (pba->has_idm_dr == _TRUE_) {
         delta_idm_dr -= 3. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
@@ -8061,10 +8716,13 @@ int perturb_print_variables(double tau,
         theta_dcdm += k*k*alpha;
       }
 
+      /*
+
       if (pba->has_scf == _TRUE_) {
         delta_scf += alpha*(-3.0*H*(1.0+pvecback[pba->index_bg_p_scf]/pvecback[pba->index_bg_rho_scf]));
         theta_scf += k*k*alpha;
       }
+      */
 
     }
 
@@ -8105,6 +8763,10 @@ int perturb_print_variables(double tau,
     class_store_double(dataptr, delta_ur, pba->has_ur, storeidx);
     class_store_double(dataptr, theta_ur, pba->has_ur, storeidx);
     class_store_double(dataptr, shear_ur, pba->has_ur, storeidx);
+    /*New EDE*/
+    class_store_double(dataptr, delta_EDE, pba->has_EDE_pert, storeidx);
+    class_store_double(dataptr, theta_EDE, pba->has_EDE_pert, storeidx);
+    class_store_double(dataptr, shear_EDE, pba->has_EDE_pert, storeidx);
     /* Interacting dark radiation */
     class_store_double(dataptr, delta_idr, pba->has_idr, storeidx);
     class_store_double(dataptr, theta_idr, pba->has_idr, storeidx);
@@ -8841,20 +9503,24 @@ int perturb_derivs(double tau,
     }
 
     /** - ---> scalar field (scf) */
+    /*New EDE*/ /*Dynamical equations for scalar fluctuations: checked*/
+
+      if ((pba->has_scf == _TRUE_) && (pba->has_EDE_pert == _TRUE_)){
+	if ( (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)) {
 
-    if (pba->has_scf == _TRUE_) {
 
       /** - ----> field value */
 
-      dy[pv->index_pt_phi_scf] = y[pv->index_pt_phi_prime_scf];
+	  dy[pv->index_pt_phi_scf] = y[pv->index_pt_phi_prime_scf];
 
       /** - ----> Klein Gordon equation */
 
-      dy[pv->index_pt_phi_prime_scf] =  - 2.*a_prime_over_a*y[pv->index_pt_phi_prime_scf]
-        - metric_continuity*pvecback[pba->index_bg_phi_prime_scf] //  metric_continuity = h'/2
-        - (k2 + a2*pvecback[pba->index_bg_ddV_scf])*y[pv->index_pt_phi_scf]; //checked
+	  dy[pv->index_pt_phi_prime_scf] =  - 2.*a_prime_over_a*y[pv->index_pt_phi_prime_scf]
+	    - metric_continuity*pvecback[pba->index_bg_phi_prime_scf] //  metric_continuity = h'/2
+	    - (k2 + a2*pvecback[pba->index_bg_ddV_scf])*y[pv->index_pt_phi_scf]; //checked
 
-    }
+	}
+      }
     /** - ---> interacting dark radiation */
     if (pba->has_idr == _TRUE_){
 
@@ -8978,7 +9644,7 @@ int perturb_derivs(double tau,
               +2./3.*(y[pv->index_pt_theta_ur]+metric_shear);
 
           }
-
+	  
           /* a la CLASS */
           if (ppr->ur_fluid_approximation == ufa_CLASS) {
 
@@ -8991,6 +9657,42 @@ int perturb_derivs(double tau,
       }
     }
 
+
+    
+/* New EDE */
+    /*These are the actual perturbation equations*/
+
+    if (pba->has_EDE_pert == _TRUE_) {
+      
+ 
+
+      if  (ppw->approx[ppw->index_ap_sda] == (int)sda_off&&(ppw->approx[ppw->index_ap_CCa] == (int)CCa_off))  {
+
+        /** - -----> EDE density */
+        dy[pv->index_pt_delta_EDE] =
+          // standard term
+          -(1. + pba->three_eos_EDE/3.)*(y[pv->index_pt_theta_EDE] + metric_continuity);
+          // non-standard term, non-zero if if ceff2_ur not 1/3
+	+(pba->three_eos_EDE - ppt->three_ceff2_EDE)*a_prime_over_a*(y[pv->index_pt_delta_EDE] + (3. + pba->three_eos_EDE)*a_prime_over_a*y[pv->index_pt_theta_EDE]/k/k);
+
+        /** - -----> EDE velocity */
+        dy[pv->index_pt_theta_EDE] =
+          // standard term with extra coefficient (3 ceff2_ur), normally equal to one
+          k2*(ppt->three_ceff2_EDE*y[pv->index_pt_delta_EDE]/(3.+pba->three_eos_EDE)-4.*s2_squared*pba->three_eos_EDE / (3. + pba->three_eos_EDE) *y[pv->index_pt_shear_EDE]) + metric_euler
+          // non-standard term, non-zero if ceff2_ur not 1/3
+          -(1.-ppt->three_ceff2_EDE)*a_prime_over_a*y[pv->index_pt_theta_EDE];
+
+	
+          /* Shear a la Hu */
+          
+	dy[pv->index_pt_shear_EDE] =
+	  -3.*a_prime_over_a*y[pv->index_pt_shear_EDE]
+	  +2./3.*ppt->three_cvis2_EDE / pba->three_eos_EDE*(y[pv->index_pt_theta_EDE]+metric_shear);
+          
+      }
+    }
+
+
     /** - ---> non-cold dark matter (ncdm): massive neutrinos, WDM, etc. */
     //TBC: curvature in all ncdm
     if (pba->has_ncdm == _TRUE_) {
