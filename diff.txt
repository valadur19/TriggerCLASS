 /**
  * Perform preliminary steps fur using the method called Pk_equal,
diff --git a/source/perturbations.c b/source/perturbations.c
index 6afc1977..aca88476 100644
--- a/source/perturbations.c
+++ b/source/perturbations.c
@@ -510,6 +510,14 @@ int perturb_init(
       printf("Computing sources\n");
   }
 
+  if (pba->has_EDE_pert && ppt->perturbations_verbose > 1){
+    printf("  -> EDE perturbation details:\n");
+    printf("     -> 3ceff2: %f, 3cvis2: %f \n",ppt->three_ceff2_EDE,ppt->three_cvis2_EDE);
+    printf("     -> Junction_tag: %d \n",pba->Junction_tag);
+    printf("     -> EDE sub dom condition: %f \n",ppr->sub_dom_cond);
+    
+  }
+
   class_test((ppt->gauge == synchronous) && (pba->has_cdm == _FALSE_),
              ppt->error_message,
              "In the synchronous gauge, it is not self-consistent to assume no CDM: the later is used to define the initial timelike hypersurface. You can either add a negligible amount of CDM or switch to newtonian gauge");
@@ -1046,6 +1054,8 @@ int perturb_indices_of_perturbs(
   ppt->has_source_delta_scf = _FALSE_;
   ppt->has_source_delta_dr = _FALSE_;
   ppt->has_source_delta_ur = _FALSE_;
+  ppt->has_source_delta_EDE = _FALSE_; 
+  ppt->has_source_theta_EDE = _FALSE_; 
   ppt->has_source_delta_idr = _FALSE_;
   ppt->has_source_delta_idm_dr = _FALSE_;
   ppt->has_source_delta_ncdm = _FALSE_;
@@ -1147,10 +1157,15 @@ int perturb_indices_of_perturbs(
           ppt->has_source_delta_dcdm = _TRUE_;
         if (pba->has_fld == _TRUE_)
           ppt->has_source_delta_fld = _TRUE_;
-        if (pba->has_scf == _TRUE_)
-          ppt->has_source_delta_scf = _TRUE_;
+	/*Ignore contribution of trigger field to density_transfer*/
+	if (pba->has_scf == _TRUE_)
+	  ppt->has_source_delta_scf = _TRUE_;
         if (pba->has_ur == _TRUE_)
           ppt->has_source_delta_ur = _TRUE_;
+
+	if (pba->has_EDE_pert == _TRUE_)
+          ppt->has_source_delta_EDE = _TRUE_;
+
         if (pba->has_idr == _TRUE_)
           ppt->has_source_delta_idr = _TRUE_;
         if (pba->has_idm_dr == _TRUE_)
@@ -1178,10 +1193,15 @@ int perturb_indices_of_perturbs(
           ppt->has_source_theta_dcdm = _TRUE_;
         if (pba->has_fld == _TRUE_)
           ppt->has_source_theta_fld = _TRUE_;
-        if (pba->has_scf == _TRUE_)
-          ppt->has_source_theta_scf = _TRUE_;
+	/*New EDE Ignore contributioin of trigger field */
+	if (pba->has_scf == _TRUE_)
+	  ppt->has_source_theta_scf = _TRUE_;
         if (pba->has_ur == _TRUE_)
           ppt->has_source_theta_ur = _TRUE_;
+	
+	if (pba->has_EDE_pert == _TRUE_)
+          ppt->has_source_theta_EDE = _TRUE_;
+	
         if (pba->has_idr == _TRUE_)
           ppt->has_source_theta_idr = _TRUE_;
         if (pba->has_idm_dr == _TRUE_)
@@ -1257,6 +1277,8 @@ int perturb_indices_of_perturbs(
       class_define_index(ppt->index_tp_delta_scf,  ppt->has_source_delta_scf, index_type,1);
       class_define_index(ppt->index_tp_delta_dr,   ppt->has_source_delta_dr,  index_type,1);
       class_define_index(ppt->index_tp_delta_ur,   ppt->has_source_delta_ur,  index_type,1);
+      class_define_index(ppt->index_tp_delta_EDE,  ppt->has_source_delta_EDE, index_type,1); 
+      class_define_index(ppt->index_tp_theta_EDE,  ppt->has_source_theta_EDE, index_type,1);
       class_define_index(ppt->index_tp_delta_idr,  ppt->has_source_delta_idr, index_type,1);
       class_define_index(ppt->index_tp_delta_idm_dr,  ppt->has_source_delta_idm_dr, index_type,1);
       class_define_index(ppt->index_tp_delta_ncdm1,ppt->has_source_delta_ncdm,index_type,pba->N_ncdm);
@@ -2577,6 +2599,8 @@ int perturb_workspace_init(
     class_define_index(ppw->index_ap_ncdmfa,pba->has_ncdm,index_ap,1);
     class_define_index(ppw->index_ap_tca_idm_dr,pba->has_idm_dr,index_ap,1);
     class_define_index(ppw->index_ap_rsa_idr,pba->has_idr,index_ap,1);
+    class_define_index(ppw->index_ap_CCa,pba->has_EDE_pert,index_ap,1);
+    class_define_index(ppw->index_ap_sda,pba->has_EDE_pert,index_ap,1); 
 
   }
 
@@ -2605,6 +2629,15 @@ int perturb_workspace_init(
     if (pba->has_ncdm == _TRUE_) {
       ppw->approx[ppw->index_ap_ncdmfa]=(int)ncdmfa_off;
     }
+
+     /*New EDE: Define CC approximation*/
+    if (pba->has_EDE_pert == _TRUE_) {
+      ppw->approx[ppw->index_ap_CCa]=(int)CCa_on;
+    }
+
+    if (pba->has_EDE_pert == _TRUE_) {
+      ppw->approx[ppw->index_ap_sda]=(int)sda_off;
+    }
   }
 
   if (_tensors_) {
@@ -3122,6 +3155,11 @@ int perturb_prepare_k_output(struct background * pba,
       class_store_columntitle(ppt->scalar_titles,"delta_ur",pba->has_ur);
       class_store_columntitle(ppt->scalar_titles,"theta_ur",pba->has_ur);
       class_store_columntitle(ppt->scalar_titles,"shear_ur",pba->has_ur);
+      /* New EDE*/
+      class_store_columntitle(ppt->scalar_titles,"delta_EDE",pba->has_EDE_pert);
+      class_store_columntitle(ppt->scalar_titles,"theta_EDE",pba->has_EDE_pert);
+      class_store_columntitle(ppt->scalar_titles,"shear_EDE",pba->has_EDE_pert);
+
       /* Interacting dark radiation */
       class_store_columntitle(ppt->scalar_titles,"delta_idr",pba->has_idr);
       class_store_columntitle(ppt->scalar_titles,"theta_idr",pba->has_idr);
@@ -3532,6 +3570,17 @@ int perturb_find_approximation_switches(
               fprintf(stdout,"Mode k=%e: will switch on ur fluid approximation at tau=%e\n",k,interval_limit[index_switch]);
             }
           }
+
+	  /*New EDE*/
+	  
+	  if (pba->has_EDE_pert == _TRUE_) {
+	    /*Here we check when the CC approximation is turned off*/
+	    if ((interval_approx[index_switch-1][ppw->index_ap_CCa]==(int)CCa_on) &&
+                (interval_approx[index_switch][ppw->index_ap_CCa]==(int)CCa_off)) {
+              fprintf(stdout,"Mode k=%e: will switch off CC approximation at tau=%e\n",k,interval_limit[index_switch]);
+	    }
+	  }
+	  
           if (pba->has_ncdm == _TRUE_) {
             if ((interval_approx[index_switch-1][ppw->index_ap_ncdmfa]==(int)ncdmfa_off) &&
                 (interval_approx[index_switch][ppw->index_ap_ncdmfa]==(int)ncdmfa_on)) {
@@ -3637,6 +3686,12 @@ int perturb_vector_init(
   int l;
   int n_ncdm,index_q,ncdm_l_size;
   double rho_plus_p_ncdm,q,q2,epsilon,a,factor;
+  /*New EDE*/
+  double amp_rel = 0.; 
+  double delta_rho_scf;
+  double rho_plus_p_theta_scf;
+  double a_prime_over_a;
+  double  delta_phi_over_phi_prime, sigma_EDE;
 
   /** - allocate a new perturb_vector structure to which ppw-->pv will point at the end of the routine */
 
@@ -3747,9 +3802,15 @@ int perturb_vector_init(
 
     /* scalar field */
 
-    class_define_index(ppv->index_pt_phi_scf,pba->has_scf,index_pt,1); /* scalar field density */
-    class_define_index(ppv->index_pt_phi_prime_scf,pba->has_scf,index_pt,1); /* scalar field velocity */
+    /*New EDE: Only track perturbations in clock field  before decay, afterwards they are irrelevant  */
 
+    if (pba->has_scf == _TRUE_){
+      if (pba->has_EDE_pert && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)){
+	class_define_index(ppv->index_pt_phi_scf,pba->has_scf,index_pt,1); /* scalar field density */
+	class_define_index(ppv->index_pt_phi_prime_scf,pba->has_scf,index_pt,1); /* scalar field velocity */
+      }
+    }
+    
     /* perturbed recombination: the indices are defined once tca is off. */
     if ( (ppt->has_perturbed_recombination == _TRUE_) && (ppw->approx[ppw->index_ap_tca] == (int)tca_off) ){
       class_define_index(ppv->index_pt_perturbed_recombination_delta_temp,_TRUE_,index_pt,1);
@@ -3770,6 +3831,16 @@ int perturb_vector_init(
       }
     }
 
+    /*New EDE*/
+    /*Here we allocate memory for the variables to be integrated depending on approximation scheme.*/
+    if (pba->has_EDE_pert  && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_off) && (ppw->approx[ppw->index_ap_sda] == (int)sda_off)  ) {
+
+      class_define_index(ppv->index_pt_delta_EDE,_TRUE_,index_pt,1); 
+      class_define_index(ppv->index_pt_theta_EDE,_TRUE_,index_pt,1); 
+      class_define_index(ppv->index_pt_shear_EDE,_TRUE_,index_pt,1); 
+    }
+    
+    
     /* interacting dark radiation */
 
     if (pba->has_idr == _TRUE_){
@@ -4084,6 +4155,16 @@ int perturb_vector_init(
 
       }
 
+      /*New EDE*/ /*Check that all modes are being initizalized before the transition*/
+      
+      if (pba->has_EDE_pert == _TRUE_) {
+
+        class_test(ppw->approx[ppw->index_ap_CCa] == (int)CCa_off,
+                   ppt->error_message,
+                   "scalar initial conditions assume EDE CC approximation turned on");
+
+      }
+
       if (pba->has_ncdm == _TRUE_) {
 
         class_test(ppw->approx[ppw->index_ap_ncdmfa] == (int)ncdmfa_on,
@@ -4215,14 +4296,14 @@ int perturb_vector_init(
         }
       }
 
-      if (pba->has_scf == _TRUE_) {
+      //if (pba->has_scf == _TRUE_) {
 
-        ppv->y[ppv->index_pt_phi_scf] =
-          ppw->pv->y[ppw->pv->index_pt_phi_scf];
+      //ppv->y[ppv->index_pt_phi_scf] =
+      //  ppw->pv->y[ppw->pv->index_pt_phi_scf];
 
-        ppv->y[ppv->index_pt_phi_prime_scf] =
-          ppw->pv->y[ppw->pv->index_pt_phi_prime_scf];
-      }
+      //ppv->y[ppv->index_pt_phi_prime_scf] =
+      //  ppw->pv->y[ppw->pv->index_pt_phi_prime_scf];
+      // }
 
       if (ppt->gauge == synchronous)
         ppv->y[ppv->index_pt_eta] =
@@ -4311,6 +4392,37 @@ int perturb_vector_init(
           }
         }
 
+
+	
+	/*New EDE*/
+	/*EDE perturbations not affectecd by tight coupling approximation, so we just copy the values from the previous integration step*/
+	if (pba->has_EDE_pert == _TRUE_ ) {
+	  if  ( (ppw->approx[ppw->index_ap_sda] == (int)sda_off) && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_off)){
+	    ppv->y[ppv->index_pt_delta_EDE] =
+	      ppw->pv->y[ppw->pv->index_pt_delta_EDE];
+
+	    ppv->y[ppv->index_pt_theta_EDE] =
+	      ppw->pv->y[ppw->pv->index_pt_theta_EDE];
+
+	    ppv->y[ppv->index_pt_shear_EDE] =
+	      ppw->pv->y[ppw->pv->index_pt_shear_EDE];
+	  }
+	}
+
+	 /*New EDE*/ /*scalar field not affected by this approximation scheme switch*/
+	if (pba->has_scf == _TRUE_) {
+	  if ((pba->has_EDE_pert) && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on) ){
+	  
+	    ppv->y[ppv->index_pt_phi_scf] =
+	      ppw->pv->y[ppw->pv->index_pt_phi_scf];
+	    
+	    ppv->y[ppv->index_pt_phi_prime_scf] =
+	      ppw->pv->y[ppw->pv->index_pt_phi_prime_scf];
+	  }
+	}
+
+
+
         if (pba->has_ncdm == _TRUE_) {
           index_pt = 0;
           for(n_ncdm = 0; n_ncdm < ppv->N_ncdm; n_ncdm++){
@@ -4393,6 +4505,34 @@ int perturb_vector_init(
             }
           }
         }
+	/*New EDE*/
+	/*EDE perturbations not affectecd by radiation streaming approximation, so we just copy the values from the previous integration step*/
+	if (pba->has_EDE_pert == _TRUE_ ) {
+	  if  ( (ppw->approx[ppw->index_ap_sda] == (int)sda_off) &&(ppw->approx[ppw->index_ap_CCa] == (int)CCa_off)){
+	    ppv->y[ppv->index_pt_delta_EDE] =
+	      ppw->pv->y[ppw->pv->index_pt_delta_EDE];
+
+	    ppv->y[ppv->index_pt_theta_EDE] =
+	      ppw->pv->y[ppw->pv->index_pt_theta_EDE];
+
+	    ppv->y[ppv->index_pt_shear_EDE] =
+	      ppw->pv->y[ppw->pv->index_pt_shear_EDE];
+	  }
+	}
+      
+
+       /*New EDE*/ /*scalar field not affected by this approximation scheme switch*/
+	if (pba->has_scf == _TRUE_) {
+	  if (pba->has_EDE_pert && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)){
+	  
+	    ppv->y[ppv->index_pt_phi_scf] =
+	      ppw->pv->y[ppw->pv->index_pt_phi_scf];
+	    
+	    ppv->y[ppv->index_pt_phi_prime_scf] =
+	      ppw->pv->y[ppw->pv->index_pt_phi_prime_scf];
+	  }
+	}
+
       }
 
       /* -- case of switching on ur fluid
@@ -4489,6 +4629,35 @@ int perturb_vector_init(
             }
           }
 
+
+	  	  /*New EDE*/
+	  /*Just copy values*/
+	  if (pba->has_EDE_pert == _TRUE_){
+	    if ((ppw->approx[ppw->index_ap_sda] == (int)sda_off) && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_off)) {
+
+	      ppv->y[ppv->index_pt_delta_EDE] =
+		ppw->pv->y[ppw->pv->index_pt_delta_EDE];
+
+	      ppv->y[ppv->index_pt_theta_EDE] =
+		ppw->pv->y[ppw->pv->index_pt_theta_EDE];
+
+	      ppv->y[ppv->index_pt_shear_EDE] =
+		ppw->pv->y[ppw->pv->index_pt_shear_EDE];
+	    }
+	  }
+
+	  if (pba->has_scf == _TRUE_) {
+	    if (pba->has_EDE_pert && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)){
+	  
+	      ppv->y[ppv->index_pt_phi_scf] =
+		ppw->pv->y[ppw->pv->index_pt_phi_scf];
+	    
+	      ppv->y[ppv->index_pt_phi_prime_scf] =
+		ppw->pv->y[ppw->pv->index_pt_phi_prime_scf];
+	    }
+	  }
+
+
           if (pba->has_ncdm == _TRUE_) {
             index_pt = 0;
             for(n_ncdm = 0; n_ncdm < ppv->N_ncdm; n_ncdm++){
@@ -4506,6 +4675,257 @@ int perturb_vector_init(
         }
       }
 
+
+
+      /*New EDE*/
+      /*Here we switch off the CC approximation / requires us to set initial conditions for all our modes / note that all other sectors are unaffected / this is quite crucial*/
+      if (pba->has_EDE_pert == _TRUE_) {
+
+        if ((pa_old[ppw->index_ap_CCa] == (int)CCa_on) && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_off)) {
+
+          if (ppt->perturbations_verbose>2)
+            fprintf(stdout,"Mode k=%e: switch off EDE CC approximation at tau=%e\n",k,tau);
+
+          if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {
+
+            ppv->y[ppv->index_pt_delta_g] =
+              ppw->pv->y[ppw->pv->index_pt_delta_g];
+
+            ppv->y[ppv->index_pt_theta_g] =
+              ppw->pv->y[ppw->pv->index_pt_theta_g];
+          }
+
+          if ((ppw->approx[ppw->index_ap_tca] == (int)tca_off) && (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off)) {
+
+            ppv->y[ppv->index_pt_shear_g] =
+              ppw->pv->y[ppw->pv->index_pt_shear_g];
+
+            ppv->y[ppv->index_pt_l3_g] =
+              ppw->pv->y[ppw->pv->index_pt_l3_g];
+
+            for (l = 4; l <= ppw->pv->l_max_g; l++) {
+
+              ppv->y[ppv->index_pt_delta_g+l] =
+                ppw->pv->y[ppw->pv->index_pt_delta_g+l];
+            }
+
+            ppv->y[ppv->index_pt_pol0_g] =
+              ppw->pv->y[ppw->pv->index_pt_pol0_g];
+
+            ppv->y[ppv->index_pt_pol1_g] =
+              ppw->pv->y[ppw->pv->index_pt_pol1_g];
+
+            ppv->y[ppv->index_pt_pol2_g] =
+              ppw->pv->y[ppw->pv->index_pt_pol2_g];
+
+            ppv->y[ppv->index_pt_pol3_g] =
+              ppw->pv->y[ppw->pv->index_pt_pol3_g];
+
+            for (l = 4; l <= ppw->pv->l_max_pol_g; l++) {
+
+              ppv->y[ppv->index_pt_pol0_g+l] =
+                ppw->pv->y[ppw->pv->index_pt_pol0_g+l];
+            }
+
+          }
+
+	  if (pba->has_ur == _TRUE_) {
+
+            if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {
+
+
+              ppv->y[ppv->index_pt_delta_ur] =
+                ppw->pv->y[ppw->pv->index_pt_delta_ur];
+
+              ppv->y[ppv->index_pt_theta_ur] =
+                ppw->pv->y[ppw->pv->index_pt_theta_ur];
+
+              ppv->y[ppv->index_pt_shear_ur] =
+                ppw->pv->y[ppw->pv->index_pt_shear_ur];
+
+              if (ppw->approx[ppw->index_ap_ufa] == (int)ufa_off) {
+
+                ppv->y[ppv->index_pt_l3_ur] =
+                  ppw->pv->y[ppw->pv->index_pt_l3_ur];
+
+                for (l=4; l <= ppv->l_max_ur; l++)
+                  ppv->y[ppv->index_pt_delta_ur+l] =
+                    ppw->pv->y[ppw->pv->index_pt_delta_ur+l];
+              }
+            }
+          }
+	  /*New EDE*/ /*important*/
+	  /*here we set the matching conditions for EDE perturbations: before transition perturbations are zero and after transition they start with value set by fluctuation in transition surface / see Israel's equations*/
+	  
+	  if ((ppw->approx[ppw->index_ap_sda] == (int)sda_off)){
+	    
+     
+	    a = ppw->pvecback[pba->index_bg_a];
+
+	  
+
+	    a_prime_over_a = ppw->pvecback[pba->index_bg_H]*a;
+	  
+	    if (pba->has_scf == _TRUE_) 
+	      delta_phi_over_phi_prime = ppw->pv->y[ppw->pv->index_pt_phi_scf] / (ppw->pvecback[pba->index_bg_phi_prime_scf] );
+	    else
+	      delta_phi_over_phi_prime = 0; //In absence of scalar field we use trivial junction conditions.  
+	  
+	    if (pba->Junction_tag == 0){
+	      amp_rel = 0.0;
+	      sigma_EDE = 0.0;
+	    }
+	    else if(pba->Junction_tag == 1){
+	      amp_rel = 1.;
+	      sigma_EDE = 0.0;
+	    }
+
+	  //printf("k: %f, aH: %f, h': %f, eta': %f, alpha1: %f, alpha2: %f \n",k,a_prime_over_a ,ppw->pvecmetric[ppw->index_mt_h_prime],ppw->pvecmetric[ppw->index_mt_eta_prime],(ppw->pvecmetric[ppw->index_mt_h_prime] + 6.0*ppw->pvecmetric[ppw->index_mt_eta_prime])/(2.0 *k*k),ppw->pvecmetric[ppw->index_mt_alpha]);
+	  
+	  	    
+	    ppv->y[ppv->index_pt_delta_EDE] =  - (3. + pba->three_eos_EDE) * amp_rel * a_prime_over_a * delta_phi_over_phi_prime;  // follows from junction conditions
+
+	    
+	    ppv->y[ppv->index_pt_theta_EDE] = - 1./(3. + pba->three_eos_EDE) * k * k / a_prime_over_a * ppv->y[ppv->index_pt_delta_EDE]; // follows from junction conditions
+
+
+	  // if (k<0.04 && k>0.03)
+	  //printf("v1: %f, v2: %f, v3: %E",k,ppw->pv->y[ppw->pv->index_pt_phi_scf], ppw->pvecback[pba->index_bg_phi_prime_scf]);
+		  
+	    // printf("z: %f and k: %f and delta_EDE: %f and theta_EDE: %f \n",1./a-1,k,ppv->y[ppv->index_pt_delta_EDE],ppv->y[ppv->index_pt_theta_EDE]);
+
+	    ppv->y[ppv->index_pt_shear_EDE] =  sigma_EDE;
+	    
+	    //the higher multipoles below we have to set to zero as they are not fixed by the junction conditions. Note that this is a gauge invariant choice.	
+	    
+	  }
+
+	  /* New EDE */ /*Scalar field evolution stops at transition.*/
+	  //  if (pba->has_scf == _TRUE_) {
+	  //if (pba->has_EDE_pert && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)){
+	  
+	  //  ppv->y[ppv->index_pt_phi_scf] =
+	  //	ppw->pv->y[ppw->pv->index_pt_phi_scf];
+	    
+	  //  ppv->y[ppv->index_pt_phi_prime_scf] =
+	  //	ppw->pv->y[ppw->pv->index_pt_phi_prime_scf];
+	  //}
+	  //}
+	  
+	  
+	  
+          if (pba->has_ncdm == _TRUE_) {
+            index_pt = 0;
+            for(n_ncdm = 0; n_ncdm < ppv->N_ncdm; n_ncdm++){
+              for(index_q=0; index_q < ppv->q_size_ncdm[n_ncdm]; index_q++){
+                for(l=0; l<=ppv->l_max_ncdm[n_ncdm]; l++){
+                  /* This is correct even when ncdmfa == off, since ppv->l_max_ncdm and
+                      ppv->q_size_ncdm is updated.*/
+                  ppv->y[ppv->index_pt_psi0_ncdm1+index_pt] =
+                    ppw->pv->y[ppw->pv->index_pt_psi0_ncdm1+index_pt];
+                  index_pt++;
+                }
+              }
+            }
+          }
+        }
+
+	if ((pa_old[ppw->index_ap_sda] == (int)sda_off) && (ppw->approx[ppw->index_ap_sda] == (int)sda_on)) {
+
+          if (ppt->perturbations_verbose>2)
+            fprintf(stdout,"Mode k=%e: switch off EDE CC approximation at tau=%e\n",k,tau);
+
+          if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {
+
+            ppv->y[ppv->index_pt_delta_g] =
+              ppw->pv->y[ppw->pv->index_pt_delta_g];
+
+            ppv->y[ppv->index_pt_theta_g] =
+              ppw->pv->y[ppw->pv->index_pt_theta_g];
+          }
+
+          if ((ppw->approx[ppw->index_ap_tca] == (int)tca_off) && (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off)) {
+
+            ppv->y[ppv->index_pt_shear_g] =
+              ppw->pv->y[ppw->pv->index_pt_shear_g];
+
+            ppv->y[ppv->index_pt_l3_g] =
+              ppw->pv->y[ppw->pv->index_pt_l3_g];
+
+            for (l = 4; l <= ppw->pv->l_max_g; l++) {
+
+              ppv->y[ppv->index_pt_delta_g+l] =
+                ppw->pv->y[ppw->pv->index_pt_delta_g+l];
+            }
+
+            ppv->y[ppv->index_pt_pol0_g] =
+              ppw->pv->y[ppw->pv->index_pt_pol0_g];
+
+            ppv->y[ppv->index_pt_pol1_g] =
+              ppw->pv->y[ppw->pv->index_pt_pol1_g];
+
+            ppv->y[ppv->index_pt_pol2_g] =
+              ppw->pv->y[ppw->pv->index_pt_pol2_g];
+
+            ppv->y[ppv->index_pt_pol3_g] =
+              ppw->pv->y[ppw->pv->index_pt_pol3_g];
+
+            for (l = 4; l <= ppw->pv->l_max_pol_g; l++) {
+
+              ppv->y[ppv->index_pt_pol0_g+l] =
+                ppw->pv->y[ppw->pv->index_pt_pol0_g+l];
+            }
+
+          }
+
+	  if (pba->has_ur == _TRUE_) {
+
+            if (ppw->approx[ppw->index_ap_rsa] == (int)rsa_off) {
+
+
+              ppv->y[ppv->index_pt_delta_ur] =
+                ppw->pv->y[ppw->pv->index_pt_delta_ur];
+
+              ppv->y[ppv->index_pt_theta_ur] =
+                ppw->pv->y[ppw->pv->index_pt_theta_ur];
+
+              ppv->y[ppv->index_pt_shear_ur] =
+                ppw->pv->y[ppw->pv->index_pt_shear_ur];
+
+              if (ppw->approx[ppw->index_ap_ufa] == (int)ufa_off) {
+
+                ppv->y[ppv->index_pt_l3_ur] =
+                  ppw->pv->y[ppw->pv->index_pt_l3_ur];
+
+                for (l=4; l <= ppv->l_max_ur; l++)
+                  ppv->y[ppv->index_pt_delta_ur+l] =
+                    ppw->pv->y[ppw->pv->index_pt_delta_ur+l];
+              }
+            }
+          }
+	  
+	  
+          if (pba->has_ncdm == _TRUE_) {
+            index_pt = 0;
+            for(n_ncdm = 0; n_ncdm < ppv->N_ncdm; n_ncdm++){
+              for(index_q=0; index_q < ppv->q_size_ncdm[n_ncdm]; index_q++){
+                for(l=0; l<=ppv->l_max_ncdm[n_ncdm]; l++){
+                  /* This is correct even when ncdmfa == off, since ppv->l_max_ncdm and
+                      ppv->q_size_ncdm is updated.*/
+                  ppv->y[ppv->index_pt_psi0_ncdm1+index_pt] =
+                    ppw->pv->y[ppw->pv->index_pt_psi0_ncdm1+index_pt];
+                  index_pt++;
+                }
+              }
+            }
+          }
+        }
+
+	
+      }
+
+
+      
       /* Case of switching on rsa for interacting dark radiation */
       if (pba->has_idr == _TRUE_) {
         if ((pa_old[ppw->index_ap_rsa_idr] == (int)rsa_idr_off) && (ppw->approx[ppw->index_ap_rsa_idr] == (int)rsa_idr_on)) {
@@ -4695,6 +5115,37 @@ int perturb_vector_init(
             }
           }
 
+
+	  	  	  /*New EDE*/
+	  /*Just copy values*/
+	  if (pba->has_EDE_pert == _TRUE_){
+	    if ((ppw->approx[ppw->index_ap_sda] == (int)sda_off)&&(ppw->approx[ppw->index_ap_CCa] == (int)CCa_off)) {
+
+	      ppv->y[ppv->index_pt_delta_EDE] =
+		ppw->pv->y[ppw->pv->index_pt_delta_EDE];
+
+	      ppv->y[ppv->index_pt_theta_EDE] =
+		ppw->pv->y[ppw->pv->index_pt_theta_EDE];
+
+	      ppv->y[ppv->index_pt_shear_EDE] =
+		ppw->pv->y[ppw->pv->index_pt_shear_EDE];
+	    }
+	  }
+
+	  if (pba->has_scf == _TRUE_) {
+	    if (pba->has_EDE_pert && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)){
+	  
+	      ppv->y[ppv->index_pt_phi_scf] =
+		ppw->pv->y[ppw->pv->index_pt_phi_scf];
+	    
+	      ppv->y[ppv->index_pt_phi_prime_scf] =
+		ppw->pv->y[ppw->pv->index_pt_phi_prime_scf];
+	    }
+	  }
+
+
+	  
+
           if (pba->has_ncdm == _TRUE_) {
             index_pt = 0;
             for(n_ncdm = 0; n_ncdm < ppv->N_ncdm; n_ncdm++){
@@ -4793,6 +5244,35 @@ int perturb_vector_init(
             }
           }
 
+
+	  	  	  /*New EDE*/
+	  /*Just copy values*/
+	  if (pba->has_EDE_pert == _TRUE_){
+	    if ((ppw->approx[ppw->index_ap_sda] == (int)sda_off)&&(ppw->approx[ppw->index_ap_CCa] == (int)CCa_off)) {
+
+	      ppv->y[ppv->index_pt_delta_EDE] =
+		ppw->pv->y[ppw->pv->index_pt_delta_EDE];
+
+	      ppv->y[ppv->index_pt_theta_EDE] =
+		ppw->pv->y[ppw->pv->index_pt_theta_EDE];
+
+	      ppv->y[ppv->index_pt_shear_EDE] =
+		ppw->pv->y[ppw->pv->index_pt_shear_EDE];
+	    }
+	  }
+
+	  if (pba->has_scf == _TRUE_) {
+	    if (pba->has_EDE_pert && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)){
+	  
+	      ppv->y[ppv->index_pt_phi_scf] =
+		ppw->pv->y[ppw->pv->index_pt_phi_scf];
+	    
+	      ppv->y[ppv->index_pt_phi_prime_scf] =
+		ppw->pv->y[ppw->pv->index_pt_phi_prime_scf];
+	    }
+	  }
+
+
           if (pba->has_idr == _TRUE_){
             if (ppw->approx[ppw->index_ap_rsa_idr] == (int)rsa_idr_off){
 
@@ -5145,6 +5625,17 @@ int perturb_initial_conditions(struct precision * ppr,
       rho_nu += ppw->pvecback[pba->index_bg_rho_ur];
     }
 
+    /*New EDE*/
+    /*Check if we need to include something here. I don't think so, because at early times EDE is not behaving like radiation.*/ /*Actually, we do need to include something here, only if intial time is set after decay has taken place*/
+    if (pba->has_EDE_pert == _TRUE_) {
+      //printf("(z: %f, k: %f )",1/a-1,k);	
+      if (pba->z_decay > 1/a-1){
+	
+	rho_r += ppw->pvecback[pba->index_bg_rho_EDE2];
+	rho_nu += ppw->pvecback[pba->index_bg_rho_EDE2];
+      }
+    }
+
     if (pba->has_idr == _TRUE_) {
       rho_r += ppw->pvecback[pba->index_bg_rho_idr];
       rho_nu += ppw->pvecback[pba->index_bg_rho_idr];
@@ -5260,7 +5751,9 @@ int perturb_initial_conditions(struct precision * ppr,
         /* if use_ppf == _TRUE_, y[ppw->pv->index_pt_Gamma_fld] will be automatically set to zero, and this is what we want (although one could probably work out some small nonzero initial conditions: TODO) */
       }
 
-      if (pba->has_scf == _TRUE_) {
+      if ((pba->has_scf == _TRUE_) && (pba->has_EDE_pert == _TRUE_)){
+	if ( (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)) {
+
         /** - ---> Canonical field (solving for the perturbations):
          *  initial perturbations set to zero, they should reach the attractor soon enough.
          *  - --->  TODO: Incorporate the attractor IC from 1004.5509.
@@ -5269,13 +5762,17 @@ int perturb_initial_conditions(struct precision * ppr,
          *  and assume theta, delta_rho as for perfect fluid
          *  with \f$ c_s^2 = 1 \f$ and w = 1/3 (ASSUMES radiation TRACKING)
          */
-
-        ppw->pv->y[ppw->pv->index_pt_phi_scf] = 0.;
+	/*New EDE*/ /*We set perturbations on the adiabatic attractor solution*/
+	
+	  ppw->pv->y[ppw->pv->index_pt_phi_scf] = pba->EDE2_clock_pert_ini * (1. - 1./6.*k*k/pow(a * ppw->pvecback[pba->index_bg_H],2) - 1./20.* pow(pba->EDE2_clock_mass / ppw->pvecback[pba->index_bg_H],2) ) - 1./140. * pba->phi_ini_scf * ppw->pv->y[ppw->pv->index_pt_delta_g] * pow(pba->EDE2_clock_mass / ppw->pvecback[pba->index_bg_H],2) ;
         /*  a*a/k/k/ppw->pvecback[pba->index_bg_phi_prime_scf]*k*ktau_three/4.*1./(4.-6.*(1./3.)+3.*1.) * (ppw->pvecback[pba->index_bg_rho_scf] + ppw->pvecback[pba->index_bg_p_scf])* ppr->curvature_ini * s2_squared; */
 
-        ppw->pv->y[ppw->pv->index_pt_phi_prime_scf] = 0.;
+	  ppw->pv->y[ppw->pv->index_pt_phi_prime_scf] = pba->EDE2_clock_pert_ini * (- 1./3.*k*k/(a * ppw->pvecback[pba->index_bg_H]) - 1./5.* pow(pba->EDE2_clock_mass,2) * a / ppw->pvecback[pba->index_bg_H] ) - 3/70 * pba->phi_ini_scf * ppw->pv->y[ppw->pv->index_pt_delta_g]*pow(pba->EDE2_clock_mass, 2) * a / ppw->pvecback[pba->index_bg_H] ;
         /* delta_fld expression * rho_scf with the w = 1/3, c_s = 1
-           a*a/ppw->pvecback[pba->index_bg_phi_prime_scf]*( - ktau_two/4.*(1.+1./3.)*(4.-3.*1.)/(4.-6.*(1/3.)+3.*1.)*ppw->pvecback[pba->index_bg_rho_scf] - ppw->pvecback[pba->index_bg_dV_scf]*ppw->pv->y[ppw->pv->index_pt_phi_scf])* ppr->curvature_ini * s2_squared; */
+            a*a/ppw->pvecback[pba->index_bg_phi_prime_scf]*( - ktau_two/4.*(1.+1./3.)*(4.-3.*1.)/(4.-6.*(1/3.)+3.*1.)*ppw->pvecback[pba->index_bg_rho_scf] - ppw->pvecback[pba->index_bg_dV_scf]*ppw->pv->y[ppw->pv->index_pt_phi_scf])* ppr->curvature_ini * s2_squared; */
+
+
+	}
       }
 
       /* all relativistic relics: ur, early ncdm, dr */
@@ -5521,17 +6018,22 @@ int perturb_initial_conditions(struct precision * ppr,
         ppw->pv->y[ppw->pv->index_pt_theta_fld] += k*k*alpha;
       }
 
+      /*New EDE*/ /*Not important*/
       /* scalar field: check */
       if (pba->has_scf == _TRUE_) {
-        alpha_prime = 0.0;
-        /* - 2. * a_prime_over_a * alpha + eta
-           - 4.5 * (a2/k2) * ppw->rho_plus_p_shear; */
-
-        ppw->pv->y[ppw->pv->index_pt_phi_scf] += alpha*ppw->pvecback[pba->index_bg_phi_prime_scf];
-        ppw->pv->y[ppw->pv->index_pt_phi_prime_scf] +=
-          (-2.*a_prime_over_a*alpha*ppw->pvecback[pba->index_bg_phi_prime_scf]
-           -a*a* dV_scf(pba,ppw->pvecback[pba->index_bg_phi_scf])*alpha
-           +ppw->pvecback[pba->index_bg_phi_prime_scf]*alpha_prime);
+	if ((pba->has_EDE_pert == _TRUE_) && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)){
+	
+	  alpha_prime = 0.0;
+      
+          /* - 2. * a_prime_over_a * alpha + eta
+             - 4.5 * (a2/k2) * ppw->rho_plus_p_shear; */
+
+	  ppw->pv->y[ppw->pv->index_pt_phi_scf] += alpha*ppw->pvecback[pba->index_bg_phi_prime_scf];
+	  ppw->pv->y[ppw->pv->index_pt_phi_prime_scf] +=
+	    (-2.*a_prime_over_a*alpha*ppw->pvecback[pba->index_bg_phi_prime_scf]
+	     -a*a* dV_scf(pba,ppw->pvecback[pba->index_bg_phi_scf])*alpha
+	     +ppw->pvecback[pba->index_bg_phi_prime_scf]*alpha_prime);
+	}
       }
 
       if ((pba->has_ur == _TRUE_) || (pba->has_ncdm == _TRUE_) || (pba->has_dr == _TRUE_)  || (pba->has_idr == _TRUE_)) {
@@ -5919,6 +6421,31 @@ int perturb_approximations(
       ppw->approx[ppw->index_ap_rsa] = (int)rsa_off;
     }
 
+
+    /*New EDE*/
+    /*define CC approximation / turned on at early times / turned off once EDE starts to decay*/
+    if (pba->has_EDE_pert == _TRUE_){
+      if (1./ppw->pvecback[pba->index_bg_a]-1. > pba->z_decay) {
+	ppw->approx[ppw->index_ap_CCa] = (int)CCa_on;
+      }
+      else {
+	ppw->approx[ppw->index_ap_CCa] = (int)CCa_off;
+      }
+      //printf("k: %e, app: %d \n",k, ppw->approx[ppw->index_ap_CCa]);
+    }
+
+    /*New EDE*/
+    /*define sd (sub dominant) approximation / turned on when after decay EDE becomes highly sub dominant and perturbations need not be tracked anymore (after decay!)*/
+    if (pba->has_EDE_pert == _TRUE_){
+      if ((1./ppw->pvecback[pba->index_bg_a]-1. < pba->z_decay*0.9) && (ppw->pvecback[pba->index_bg_rho_EDE2]/pow(ppw->pvecback[pba->index_bg_H],2)< ppr->sub_dom_cond )) {
+	ppw->approx[ppw->index_ap_sda] = (int)sda_on;
+      }
+      else {
+	ppw->approx[ppw->index_ap_sda] = (int)sda_off;
+      }
+      //printf("k: %e, app: %d \n",k, ppw->approx[ppw->index_ap_CCa]);
+    }
+
     /* interacting dark radiation free streaming approximation*/
     if (pba->has_idr == _TRUE_){
 
@@ -6461,6 +6988,12 @@ int perturb_total_stress_energy(
   double delta_ur=0.;
   double theta_ur=0.;
   double shear_ur=0.;
+  /*New EDE*/
+  double delta_EDE=0.;
+  double theta_EDE=0.;
+  double shear_EDE=0.;
+  
+  
   double delta_idr=0.;
   double theta_idr=0.;
   double shear_idr=0.;
@@ -6569,6 +7102,31 @@ int perturb_total_stress_energy(
 
     }
 
+    /*New EDE*/
+    /*Here the Einstein pert. equation is solved, requires the values of the matter sector*/
+    if (pba->has_EDE_pert == _TRUE_) {
+
+      if ((ppw->approx[ppw->index_ap_sda] == (int)sda_off) && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_off)) {
+
+        delta_EDE = y[ppw->pv->index_pt_delta_EDE];
+        theta_EDE = y[ppw->pv->index_pt_theta_EDE];
+        shear_EDE = y[ppw->pv->index_pt_shear_EDE];
+
+      }
+
+      else {
+
+        delta_EDE = 0.; /* actual free streaming approximation imposed after evaluation of 1st einstein equation */
+        theta_EDE = 0.; /* actual free streaming approximation imposed after evaluation of 1st einstein equation */
+        shear_EDE = 0.; /* shear always neglected in free streaming approximation */
+
+      }
+
+    }
+
+
+    
+
     /** - ---> (a.3.) baryon pressure perturbation */
 
     if ((ppt->has_perturbed_recombination == _TRUE_) &&(ppw->approx[ppw->index_ap_tca] == (int)tca_off)) {
@@ -6604,6 +7162,8 @@ int perturb_total_stress_energy(
       }
     }
 
+    
+
     /** - --> (b) compute the total density, velocity and shear perturbations */
 
     /* photon and baryon contribution */
@@ -6648,7 +7208,7 @@ int perturb_total_stress_energy(
     if (pba->has_idm_dr == _TRUE_) {
       ppw->delta_rho += ppw->pvecback[pba->index_bg_rho_idm_dr]*y[ppw->pv->index_pt_delta_idm_dr];
       ppw->rho_plus_p_theta += ppw->pvecback[pba->index_bg_rho_idm_dr]*y[ppw->pv->index_pt_theta_idm_dr];
-      rho_plus_p_tot += ppw->pvecback[pba->index_bg_rho_idm_dr];
+      ppw->rho_plus_p_tot += ppw->pvecback[pba->index_bg_rho_idm_dr];
     }
 
     /* dcdm contribution */
@@ -6703,7 +7263,7 @@ int perturb_total_stress_energy(
       if (ppt->idr_nature==idr_free_streaming)
         ppw->rho_plus_p_shear += 4./3.*ppw->pvecback[pba->index_bg_rho_idr]*shear_idr;
       ppw->delta_p += 1./3. * ppw->pvecback[pba->index_bg_rho_idr]*delta_idr;
-      rho_plus_p_tot += 4./3. * ppw->pvecback[pba->index_bg_rho_idr];
+      ppw->rho_plus_p_tot += 4./3. * ppw->pvecback[pba->index_bg_rho_idr];
     }
 
     /* infer delta_cb abd theta_cb (perturbations from CDM and baryons) before adding ncdm */
@@ -6714,7 +7274,27 @@ int perturb_total_stress_energy(
         ((ppt->has_source_delta_cb == _TRUE_) || (ppt->has_source_theta_cb == _TRUE_)))
       ppw->theta_cb = rho_plus_p_theta_m/rho_plus_p_m;
 
+    
+    /*New EDE*/ /*Change!!*/
+    /*Here everything is added up. Note that we excluded the CC phase as there are no contributions in that case. This part is important as it describes the feedback of the EDE pert. into the gravitational sector.*/
+    if ((pba->has_EDE_pert == _TRUE_) && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_off) && (ppw->approx[ppw->index_ap_sda] == (int)sda_off) ) {
+      ppw->delta_rho = ppw->delta_rho + ppw->pvecback[pba->index_bg_rho_EDE2]*delta_EDE; //checked
+      ppw->rho_plus_p_theta = ppw->rho_plus_p_theta + (1.+pba->three_eos_EDE/3.)*ppw->pvecback[pba->index_bg_rho_EDE2]*theta_EDE; //checked
+      ppw->rho_plus_p_shear = ppw->rho_plus_p_shear + (1.+pba->three_eos_EDE/3.)*ppw->pvecback[pba->index_bg_rho_EDE2]*shear_EDE; //checked
+      //ppw->delta_p += pba->three_eos_EDE/3.*ppw->pvecback[pba->index_bg_rho_EDE2]*delta_EDE; 
+      ppw->delta_p += ppt->three_ceff2_EDE/3. * ppw->pvecback[pba->index_bg_rho_EDE2]*delta_EDE + (ppt->three_ceff2_EDE/3. - pba->three_eos_EDE / 3.)*(3.*a_prime_over_a* ((1.+pba->three_eos_EDE/3.)*ppw->pvecback[pba->index_bg_rho_EDE2]*theta_EDE)/k/k);
+
+      /* This part is implemented overly correct as first case cannot happen*/
+      if ( 1. / a - 1.  > pba->z_decay) {
+	ppw->rho_plus_p_tot += 0.0;
+      }
+      else {
+	ppw->rho_plus_p_tot += (1. + pba->three_eos_EDE/3.) * ppw->pvecback[pba->index_bg_rho_EDE2]; //checked
+      }
+    }
+
 
+    
     /* non-cold dark matter contribution */
     if (pba->has_ncdm == _TRUE_) {
       idx = ppw->pv->index_pt_psi0_ncdm1;
@@ -6809,41 +7389,49 @@ int perturb_total_stress_energy(
        from rho_plus_p_shear. So the contribution from the scalar field must be below all
        species with non-zero shear.
     */
-    if (pba->has_scf == _TRUE_) {
 
-      if (ppt->gauge == synchronous){
-        delta_rho_scf =  1./3.*
-          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
-           + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]);
-        delta_p_scf = 1./3.*
-          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
-           - ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]);
-      }
-      else{
-        /* equation for psi */
-        psi = y[ppw->pv->index_pt_phi] - 4.5 * (a2/k/k) * ppw->rho_plus_p_shear;
 
-        delta_rho_scf =  1./3.*
-          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
-           + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
-           - 1./a2*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*psi);
-        delta_p_scf =  1./3.*
-          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
-           - ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
-           - 1./a2*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*psi);
-      }
+     /*New EDE*/ /*Tag3 This is the feedback of the scalar perturbation in the metric sector.*/
+    if ((pba->has_scf == _TRUE_) && (pba->has_EDE_pert == _TRUE_)  ){
+      if (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on) {
 
-      ppw->delta_rho += delta_rho_scf;
+	if (ppt->gauge == synchronous){ //Is factor 1./3. correct? I think so.
+	  delta_rho_scf =  1./3.*
+	    (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
+	     + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]);
+	  delta_p_scf = 1./3.*
+	    (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
+	     - ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]);
+	}
+	else{
+	  /* equation for psi */
+	  psi = y[ppw->pv->index_pt_phi] - 4.5 * (a2/k/k) * ppw->rho_plus_p_shear;
+	  
+	  delta_rho_scf =  1./3.*
+	    (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
+	     + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
+	     - 1./a2*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*psi);
+	  delta_p_scf =  1./3.*
+	    (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
+	     - ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
+	     - 1./a2*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*psi);
+	}
+	
+	
 
-      ppw->rho_plus_p_theta +=  1./3.*
-        k*k/a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_scf];
+	ppw->delta_rho += delta_rho_scf;
 
-      ppw->delta_p += delta_p_scf;
+	ppw->rho_plus_p_theta +=  1./3.*
+	  k*k/a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_scf];
 
-      ppw->rho_plus_p_tot += ppw->pvecback[pba->index_bg_rho_scf]+ppw->pvecback[pba->index_bg_p_scf];
+	ppw->delta_p += delta_p_scf;
 
+	ppw->rho_plus_p_tot += ppw->pvecback[pba->index_bg_rho_scf]+ppw->pvecback[pba->index_bg_p_scf];
+
+      }
     }
 
+
     /* add your extra species here */
 
     /* fluid contribution */
@@ -6916,8 +7504,8 @@ int perturb_total_stress_energy(
 	Z = 2./3.*k2*ppw->pvecback[pba->index_bg_H]/a;
 	Z_prime = Z*(ppw->pvecback[pba->index_bg_H_prime]/ppw->pvecback[pba->index_bg_H] - a_prime_over_a);
 	/** Construct theta_t and its derivative from the Euler equation */
-	theta_t = ppw->rho_plus_p_theta/rho_plus_p_tot;
-	theta_t_prime = -a_prime_over_a*theta_t-(p_t_prime*theta_t-k2*ppw->delta_p +k2*ppw->rho_plus_p_shear)/rho_plus_p_tot+metric_euler;
+	theta_t = ppw->rho_plus_p_theta/ppw->rho_plus_p_tot;
+	theta_t_prime = -a_prime_over_a*theta_t-(p_t_prime*theta_t-k2*ppw->delta_p +k2*ppw->rho_plus_p_shear)/ppw->rho_plus_p_tot+metric_euler;
 	S = ppw->S_fld;
 	S_prime = -Z_prime/Z*S+1./Z*(rho_fld_prime+p_fld_prime)*(theta_t+k2*alpha)+1./Z*(rho_fld+p_fld)*(theta_t_prime+k2*alpha_prime);
 	/** Analytic derivative of the equation for ppw->rho_plus_p_theta_fld above. */
@@ -7451,22 +8039,24 @@ int perturb_sources(
         + 3.*a_prime_over_a*(1.+pvecback[pba->index_bg_w_fld])*theta_over_k2; // N-body gauge correction
     }
 
-    /* delta_scf */
-    if (ppt->has_source_delta_scf == _TRUE_) {
-      if (ppt->gauge == synchronous){
-        delta_rho_scf =  1./3.*
-          (1./a2_rel*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
-           + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf])
-          + 3.*a_prime_over_a*(1.+pvecback[pba->index_bg_p_scf]/pvecback[pba->index_bg_rho_scf])*theta_over_k2; // N-body gauge correction
-      }
-      else{
-        delta_rho_scf =  1./3.*
-          (1./a2_rel*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
-           + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
-           - 1./a2_rel*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*ppw->pvecmetric[ppw->index_mt_psi])
-          + 3.*a_prime_over_a*(1.+pvecback[pba->index_bg_p_scf]/pvecback[pba->index_bg_rho_scf])*theta_over_k2; // N-body gauge correction
+    /*New EDE*/
+    if (pba->has_EDE_pert == _TRUE_ && pba->has_scf == _TRUE_){
+      if (ppt->has_source_delta_scf == _TRUE_) {
+	if((ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)){
+	  if (ppt->gauge == synchronous){
+	    delta_rho_scf =  1./3.*
+	      (1./a2_rel*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
+	       + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]);
+	  }
+	  else{
+	    delta_rho_scf =  1./3.*
+	      (1./a2_rel*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
+	       + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
+	       - 1./a2_rel*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*ppw->pvecmetric[ppw->index_mt_psi]);
+	  }
+	  _set_source_(ppt->index_tp_delta_scf) = delta_rho_scf/pvecback[pba->index_bg_rho_scf];
+	}	
       }
-      _set_source_(ppt->index_tp_delta_scf) = delta_rho_scf/pvecback[pba->index_bg_rho_scf];
     }
 
     /* delta_dr */
@@ -7486,6 +8076,15 @@ int perturb_sources(
           + 4.*a_prime_over_a*theta_over_k2; // N-body gauge correction
     }
 
+    /* New EDE */
+    /*This part is relevant if we calculate matter transfer function as needed for sigma8*/
+    if (ppt->has_source_delta_EDE == _TRUE_) {
+      if ((ppw->approx[ppw->index_ap_sda] == (int)sda_off) &&(ppw->approx[ppw->index_ap_CCa]==(int)CCa_off))
+        _set_source_(ppt->index_tp_delta_EDE) = y[ppw->pv->index_pt_delta_EDE];
+      else
+	_set_source_(ppt->index_tp_delta_EDE) = 0.0;
+    }
+
     /* delta_idr */
     if (ppt->has_source_delta_idr == _TRUE_) {
       if (ppw->approx[ppw->index_ap_rsa_idr]==(int)rsa_idr_off)
@@ -7577,15 +8176,22 @@ int perturb_sources(
     }
 
     /* theta_scf */
-    if (ppt->has_source_theta_scf == _TRUE_) {
-
-      rho_plus_p_theta_scf = 1./3.*
-        k*k/a2_rel*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_scf];
 
-      _set_source_(ppt->index_tp_theta_scf) = rho_plus_p_theta_scf/(pvecback[pba->index_bg_rho_scf]+pvecback[pba->index_bg_p_scf])
-        + theta_shift; // N-body gauge correction
+    /*New EDE*/
+    if ((pba->has_EDE_pert == _TRUE_) && pba->has_scf == _TRUE_){
+      if (ppt->has_source_theta_scf == _TRUE_) {
+	if(ppw->approx[ppw->index_ap_CCa] == (int)CCa_on){
+	  rho_plus_p_theta_scf = 1./3.*
+	    k*k/a2_rel*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_scf];
+	  _set_source_(ppt->index_tp_theta_scf) = rho_plus_p_theta_scf/
+	    (pvecback[pba->index_bg_rho_scf]+pvecback[pba->index_bg_p_scf]);
+	}
+	//else{
+	//_set_source_(ppt->index_tp_theta_scf) = 0.0;
+	//}
+      }
     }
-
+    
     /* theta_dr */
     if (ppt->has_source_theta_dr == _TRUE_) {
 
@@ -7605,6 +8211,16 @@ int perturb_sources(
           + theta_shift; // N-body gauge correction
     }
 
+    /*New EDE*/
+    /*same for theta*/
+    if (ppt->has_source_theta_EDE == _TRUE_) {
+      if ((ppw->approx[ppw->index_ap_sda]==(int)sda_off)&&(ppw->approx[ppw->index_ap_CCa]==(int)CCa_off))
+        _set_source_(ppt->index_tp_theta_EDE) = y[ppw->pv->index_pt_theta_EDE];
+      else
+	_set_source_(ppt->index_tp_theta_EDE) = 0.0;
+    }
+
+    
     /* theta_idr */
     if (ppt->has_source_theta_idr == _TRUE_) {
       if (ppw->approx[ppw->index_ap_rsa_idr]==(int)rsa_idr_off)
@@ -7718,6 +8334,7 @@ int perturb_print_variables(double tau,
   double delta_dcdm=0.,theta_dcdm=0.;
   double delta_dr=0.,theta_dr=0.,shear_dr=0., f_dr=1.0;
   double delta_ur=0.,theta_ur=0.,shear_ur=0.,l4_ur=0.;
+  double delta_EDE=0.,theta_EDE=0.,shear_EDE=0.;
   double delta_idr=0., theta_idr=0., shear_idr=0.;
   double delta_rho_scf=0., rho_plus_p_theta_scf=0.;
   double delta_scf=0., theta_scf=0.;
@@ -7859,6 +8476,25 @@ int perturb_print_variables(double tau,
       }
     }
 
+
+    /*New EDE*/
+    /* Here we infer the perturbations for different approximations in order to print them in a file*/
+    if (pba->has_EDE_pert == _TRUE_) {
+      if ((ppw->approx[ppw->index_ap_sda]==(int)sda_off)&&(ppw->approx[ppw->index_ap_CCa]==(int)CCa_off)) {
+        delta_EDE = y[ppw->pv->index_pt_delta_EDE];
+        theta_EDE = y[ppw->pv->index_pt_theta_EDE];
+        shear_EDE = y[ppw->pv->index_pt_shear_EDE];
+      }
+      else {
+        delta_EDE = 0.;
+        theta_EDE = 0.;
+        shear_EDE = 0.;
+      }
+    }
+
+
+    
+
     delta_b = y[ppw->pv->index_pt_delta_b];
     theta_b = y[ppw->pv->index_pt_theta_b];
 
@@ -7992,33 +8628,41 @@ int perturb_print_variables(double tau,
       shear_dr = y[ppw->pv->index_pt_F0_dr+2]*0.5/f_dr;
     }
 
-    if (pba->has_scf == _TRUE_){
-      if (ppt->gauge == synchronous){
-        delta_rho_scf =  1./3.*
-          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
-           + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]);
-      }
-      else{
-        delta_rho_scf =  1./3.*
-          (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
-           + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
-           - 1./a2*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*ppw->pvecmetric[ppw->index_mt_psi]);
-      }
+        /*New EDE*/ /*To do: check!*/
 
-      rho_plus_p_theta_scf =  1./3.*
-        k*k/a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_scf];
+    if ((pba->has_scf == _TRUE_) && (pba->has_EDE_pert == _TRUE_)){
+    
+      if ( (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)){
+	if (ppt->gauge == synchronous){
+	  delta_rho_scf =  1./3.*
+	    (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
+	     + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]);
+	}
+	else{
+	  delta_rho_scf =  1./3.*
+	    (1./a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_prime_scf]
+	     + ppw->pvecback[pba->index_bg_dV_scf]*y[ppw->pv->index_pt_phi_scf]
+	     - 1./a2*pow(ppw->pvecback[pba->index_bg_phi_prime_scf],2)*ppw->pvecmetric[ppw->index_mt_psi]);
+	}
 
-      delta_scf = delta_rho_scf/pvecback[pba->index_bg_rho_scf];
-      theta_scf = rho_plus_p_theta_scf/(pvecback[pba->index_bg_rho_scf]+pvecback[pba->index_bg_p_scf]);
+	rho_plus_p_theta_scf =  1./3.*
+	  k*k/a2*ppw->pvecback[pba->index_bg_phi_prime_scf]*y[ppw->pv->index_pt_phi_scf];
 
+	delta_scf = delta_rho_scf/pvecback[pba->index_bg_rho_scf];
+	theta_scf = rho_plus_p_theta_scf; ///(pvecback[pba->index_bg_rho_scf]+pvecback[pba->index_bg_p_scf]);
+	/*New EDE*/ /*Note non standard definition to avoid singularities*/	
+      }
     }
 
+
+    
+
     /* converting synchronous variables to newtonian ones */
     if (ppt->gauge == synchronous) {
 
       /* density and velocity perturbations (comment out if you wish to keep synchronous variables) */
 
-      delta_g -= 4. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
+      /*delta_g -= 4. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
       theta_g += k*k*alpha;
 
       delta_b -= 3. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
@@ -8027,7 +8671,18 @@ int perturb_print_variables(double tau,
       if (pba->has_ur == _TRUE_) {
         delta_ur -= 4. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
         theta_ur += k*k*alpha;
+	}*/
+
+            /*New EDE*/
+      /*Here we convert to Newtonian gauge, not really important for running of code but for plotting / Note that the conversion is only well-defined if the equation of state is not -1*/
+
+      /*
+      if ((pba->has_EDE_pert == _TRUE_) && (ppw->approx[ppw->index_ap_CCa] == (int)CCa_off) ) {
+	delta_EDE -= 4. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
+        theta_EDE += k*k*alpha;
       }
+      */
+
 
       if (pba->has_idr == _TRUE_) {
         delta_idr -= 4. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
@@ -8039,11 +8694,11 @@ int perturb_print_variables(double tau,
 
         theta_dr += k*k*alpha;
       }
-
+      /*
       if (pba->has_cdm == _TRUE_) {
         delta_cdm -= 3. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
         theta_cdm += k*k*alpha;
-      }
+	}*/
 
       if (pba->has_idm_dr == _TRUE_) {
         delta_idm_dr -= 3. * pvecback[pba->index_bg_H]*pvecback[pba->index_bg_a]*alpha;
@@ -8061,10 +8716,13 @@ int perturb_print_variables(double tau,
         theta_dcdm += k*k*alpha;
       }
 
+      /*
+
       if (pba->has_scf == _TRUE_) {
         delta_scf += alpha*(-3.0*H*(1.0+pvecback[pba->index_bg_p_scf]/pvecback[pba->index_bg_rho_scf]));
         theta_scf += k*k*alpha;
       }
+      */
 
     }
 
@@ -8105,6 +8763,10 @@ int perturb_print_variables(double tau,
     class_store_double(dataptr, delta_ur, pba->has_ur, storeidx);
     class_store_double(dataptr, theta_ur, pba->has_ur, storeidx);
     class_store_double(dataptr, shear_ur, pba->has_ur, storeidx);
+    /*New EDE*/
+    class_store_double(dataptr, delta_EDE, pba->has_EDE_pert, storeidx);
+    class_store_double(dataptr, theta_EDE, pba->has_EDE_pert, storeidx);
+    class_store_double(dataptr, shear_EDE, pba->has_EDE_pert, storeidx);
     /* Interacting dark radiation */
     class_store_double(dataptr, delta_idr, pba->has_idr, storeidx);
     class_store_double(dataptr, theta_idr, pba->has_idr, storeidx);
@@ -8841,20 +9503,24 @@ int perturb_derivs(double tau,
     }
 
     /** - ---> scalar field (scf) */
+    /*New EDE*/ /*Dynamical equations for scalar fluctuations: checked*/
+
+      if ((pba->has_scf == _TRUE_) && (pba->has_EDE_pert == _TRUE_)){
+	if ( (ppw->approx[ppw->index_ap_CCa] == (int)CCa_on)) {
 
-    if (pba->has_scf == _TRUE_) {
 
       /** - ----> field value */
 
-      dy[pv->index_pt_phi_scf] = y[pv->index_pt_phi_prime_scf];
+	  dy[pv->index_pt_phi_scf] = y[pv->index_pt_phi_prime_scf];
 
       /** - ----> Klein Gordon equation */
 
-      dy[pv->index_pt_phi_prime_scf] =  - 2.*a_prime_over_a*y[pv->index_pt_phi_prime_scf]
-        - metric_continuity*pvecback[pba->index_bg_phi_prime_scf] //  metric_continuity = h'/2
-        - (k2 + a2*pvecback[pba->index_bg_ddV_scf])*y[pv->index_pt_phi_scf]; //checked
+	  dy[pv->index_pt_phi_prime_scf] =  - 2.*a_prime_over_a*y[pv->index_pt_phi_prime_scf]
+	    - metric_continuity*pvecback[pba->index_bg_phi_prime_scf] //  metric_continuity = h'/2
+	    - (k2 + a2*pvecback[pba->index_bg_ddV_scf])*y[pv->index_pt_phi_scf]; //checked
 
-    }
+	}
+      }
     /** - ---> interacting dark radiation */
     if (pba->has_idr == _TRUE_){
 
@@ -8978,7 +9644,7 @@ int perturb_derivs(double tau,
               +2./3.*(y[pv->index_pt_theta_ur]+metric_shear);
 
           }
-
+	  
           /* a la CLASS */
           if (ppr->ur_fluid_approximation == ufa_CLASS) {
 
@@ -8991,6 +9657,42 @@ int perturb_derivs(double tau,
       }
     }
 
+
+    
+/* New EDE */
+    /*These are the actual perturbation equations*/
+
+    if (pba->has_EDE_pert == _TRUE_) {
+      
+ 
+
+      if  (ppw->approx[ppw->index_ap_sda] == (int)sda_off&&(ppw->approx[ppw->index_ap_CCa] == (int)CCa_off))  {
+
+        /** - -----> EDE density */
+        dy[pv->index_pt_delta_EDE] =
+          // standard term
+          -(1. + pba->three_eos_EDE/3.)*(y[pv->index_pt_theta_EDE] + metric_continuity);
+          // non-standard term, non-zero if if ceff2_ur not 1/3
+	+(pba->three_eos_EDE - ppt->three_ceff2_EDE)*a_prime_over_a*(y[pv->index_pt_delta_EDE] + (3. + pba->three_eos_EDE)*a_prime_over_a*y[pv->index_pt_theta_EDE]/k/k);
+
+        /** - -----> EDE velocity */
+        dy[pv->index_pt_theta_EDE] =
+          // standard term with extra coefficient (3 ceff2_ur), normally equal to one
+          k2*(ppt->three_ceff2_EDE*y[pv->index_pt_delta_EDE]/(3.+pba->three_eos_EDE)-4.*s2_squared*pba->three_eos_EDE / (3. + pba->three_eos_EDE) *y[pv->index_pt_shear_EDE]) + metric_euler
+          // non-standard term, non-zero if ceff2_ur not 1/3
+          -(1.-ppt->three_ceff2_EDE)*a_prime_over_a*y[pv->index_pt_theta_EDE];
+
+	
+          /* Shear a la Hu */
+          
+	dy[pv->index_pt_shear_EDE] =
+	  -3.*a_prime_over_a*y[pv->index_pt_shear_EDE]
+	  +2./3.*ppt->three_cvis2_EDE / pba->three_eos_EDE*(y[pv->index_pt_theta_EDE]+metric_shear);
+          
+      }
+    }
+
+
     /** - ---> non-cold dark matter (ncdm): massive neutrinos, WDM, etc. */
     //TBC: curvature in all ncdm
     if (pba->has_ncdm == _TRUE_) {
